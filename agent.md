ехническое задание: Веб-сайт художника в авангардной эстетике
Обзор проекта
Данный проект подразумевает разработку современного веб-сайта художника с авангардным дизайном и насыщенной визуальной составляющей. Сайт должен иметь тёмную тему оформления, крупные изображения работ и передавать художественную атмосферу. Он будет поддерживать две языковые версии (русскую и английскую) для охвата широкой аудитории. Планируется реализовать онлайн-каталог физических работ художника с возможностью фильтрации по категории, размеру, цене и году, а также функцию продажи работ через интернет.
Ключевые возможности сайта:
•	Темная тема и авангардный дизайн: Дизайн сайта выполнен в современной тёмной цветовой палитре с акцентом на большие изображения работ, чтобы создать атмосферу, соответствующую стилю художника. Интерфейс должен быть минималистичным, но экспрессивным, отражая дух авангарда.
•	Мультиязычность: Реализована поддержка по крайней мере двух языков – русского и английского. Пользователь сможет переключать язык интерфейса и контента (описания работ, тексты разделов) без перезагрузки страницы.
•	Каталог работ: Страница каталога отображает все работы художника сеткой изображений. Предусмотрены фильтры по категории произведения, его размеру (габаритам), ценовому диапазону и году создания для удобства навигации по каталогу.
•	Карточка работы: У каждой работы будет отдельная страница с подробным описанием – высокоразрешенные изображения (возможно, несколько ракурсов), название, описание, год создания, размер, категория, цена и статус (в наличии или продано). Отсюда пользователь сможет добавить работу в корзину для покупки.
•	Интернет-магазин: Сайт включает функциональность электронной торговли – пользователи могут добавлять работы в корзину, оформлять заказ и оплачивать работы. На первом этапе интеграция платежного шлюза будет условной (заглушка), то есть без реальной обработки платежей, но архитектура должна предусматривать возможность подключения реального платежного провайдера в будущем (например, Stripe или PayPal).
•	Фиксированная доставка: При оформлении заказа стоимость доставки рассчитывается по фиксированной ставке (например, фиксированная сумма вне зависимости от адреса) на первом этапе разработки.
•	Личный кабинет пользователя: Зарегистрированные пользователи (покупатели) имеют личный кабинет, где могут просматривать свои данные, историю заказов, статусы покупок и вести переписку с администратором.
•	Админ-панель художника: Отдельный раздел сайта для администратора (самого художника или его представителя) с авторизацией. В админ-панели доступны возможности управления сайтом: добавление/редактирование работ в каталоге, управление категориями, просмотр и обработка заказов, общение с пользователями через чат и изменение содержимого статических страниц (например, раздел "О художнике").
•	Онлайн-чат с администрацией: На сайте реализован реального времени чат для связи пользователя с администратором. Бэкенд чата основан на сервисах Firebase – сообщения хранятся в Cloud Firestore и обновляются у обоих сторон в режиме реального времениfreecodecamp.org. Пользователи могут задавать вопросы прямо на сайте, а администратор сможет отвечать через интерфейс админ-панели (на первом этапе – через консоль Firebase как упрощенный вариант).
•	Авторизация через Firebase: Для управления пользователями используется Firebase Authentication. Пользователи (и администратор) регистрируются и логинятся через Firebase Auth. Данные профиля пользователей (контактные данные, адрес доставки и т.д.) хранятся во внешней базе данных MongoDB. Такой подход сочетает удобство готового решения авторизации Firebase с возможностью гибкого хранения и запросов сложных данных в MongoDBmongodb.comtempmail.us.com.
•	Интеграция с Firebase Firestore для чата: Переписка в чате пользователя с администратором сохраняется в базе данных в режиме реального времени. Firebase Firestore обеспечивает хранение сообщений в виде документов в коллекциях и автоматическую синхронизацию между клиентамиfreecodecamp.org. Это означает, что новые сообщения мгновенно появляются у собеседников без перезагрузки страницы.
•	Структура разделов сайта: Планируются следующие основные страницы и разделы: Главная страница, Каталог работ, Страница отдельной работы, Страница "О художнике", Контакты, Личный кабинет пользователя, Админ-панель. Навигация должна быть интуитивно понятной, обеспечивая быстрый доступ к интересующему контенту.
•	Запас по функционалу AR (дополненная реальность): Предусмотрена возможность в будущем добавить просмотр работ в дополненной реальности. Например, чтобы пользователь мог через камеру смартфона "разместить" картину на своей стене и оценить, как она будет выглядеть в интерьере. Рассматриваются технологии WebXR, либо сторонние сервисы вроде 8thWall для реализации AR-функций. На этапе текущей реализации данная функция закладывается архитектурно (например, кнопка "Посмотреть в AR" на странице работы, пока неактивная), чтобы в будущем интегрировать соответствующий модуль без кардинальной переработки сайта.
Этапы реализации проекта
Проект будет разбит на несколько этапов, чтобы поэтапно внедрять функциональность и обеспечивать контролируемое развитие:
1.	Этап 1: Проектирование и базовая реализация (MVP) – На первом этапе создаются основы сайта:
o	Разработка дизайна и макетов ключевых страниц (с учетом тёмной темы и авангардного стиля).
o	Настройка инфраструктуры проекта: инициализация репозитория, настройка сборки фронтенда (например, с использованием Create React App или Vite), настройка сервера Node.js и подключение к базе данных MongoDB.
o	Реализация многоязычности в интерфейсе: подготовка файлов локализации для русского и английского языков, переключатель языка.
o	Создание компонентов главной страницы, каталога и страницы деталей работы с заглушками данных.
o	Настройка Firebase Authentication для авторизации пользователей: подключение SDK на фронтенде, базовые формы регистрации/входа.
o	Создание базовой структуры бэкенда (Node.js + Express): реализация API эндпоинтов для получения списка работ, информации о конкретной работе, а также оформления заказа (пока без оплаты).
o	Интеграция бэкенда с Firebase Auth – защита нужных маршрутов (например, эндпоинтов оформления заказа или доступа в админ-панель) с проверкой токена пользователя через Firebase Admin SDK.
o	Реализация личного кабинета пользователя с отображением информации профиля (имя, email из Firebase), а также заглушкой под историю заказов.
o	Реализация простейшей версии админ-панели: защищенный доступ для администратора, возможность создавать и редактировать записи каталога (CRUD для работ) через простой интерфейс (например, форма добавления новой работы), а также просмотр списка заказов.
o	Чат: подключение Firebase Firestore, реализация на фронтенде компонента чата для пользователя. На этом этапе администратор будет отвечать через консоль Firebase (просматривая и добавляя сообщения в соответствующей коллекции).
o	Тестирование MVP: проверка корректности работы ключевых сценариев (просмотр работ, регистрация, добавление в корзину, оформление заказа с фиксированной доставкой, отправка сообщений в чат и получение ответов).
2.	Этап 2: Расширение функциональности и улучшение UX – После успешного MVP, добавляются дополнительные возможности и улучшается удобство:
o	Интеграция платёжного шлюза: Подключение реального механизма оплаты. Например, интеграция API платежей (Stripe, PayPal или другой провайдер) для приема платежей за работы. Реализация безопасного процесса оплаты и обратной связи о результате (успешно/неуспешно) в интерфейсе.
o	Расширенная корзина: Хранение состояния корзины в базе (чтобы пользователь мог восстановить корзину при повторном визите, на разных устройствах). Добавление возможности изменять количество экземпляров (хотя в случае арт-объектов, вероятно, каждый товар уникален и штука 1).
o	Улучшение админ-панели: Добавление интерфейса чата для администратора внутри админ-панели, чтобы не требовалось использовать Firebase Console. Реализация раздела "Сообщения пользователей" с перечнем диалогов по пользователям и возможностью отвечать в реальном времени. Также добавление уведомлений администратору о новых сообщениях или новых заказах (например, простым индикатором).
o	Оптимизация фильтров в каталоге: Более продвинутые фильтры (например, выбор диапазона цен с помощью ползунка, множественный выбор категорий), пагинация или динамическая подгрузка работ при прокрутке.
o	Локализация контента: При необходимости, перевод описаний работ и статического текста "О художнике" на оба языка. Возможно, создание в админ-панели возможностей редактировать тексты для разных языков.
o	Анимации и интерактивность: Добавление более сложных анимаций, эффектов при наведении, плавных переходов между страницами, чтобы улучшить визуальное восприятие (с соблюдением баланса, чтобы не отвлекать от работ).
o	SEO и SSR (при необходимости): Оптимизация сайта для поисковых систем – добавление мета-тэгов для каждой страницы (название работы, описание и пр.), возможно, внедрение серверного рендеринга (например, переход на Next.js) для улучшения индексации контента (особенно важного для страницы каталога и страниц работ).
o	Тестирование и отладка: Регресс-тестирование всех новых функций, обеспечение сохранения работоспособности MVP-функций.
3.	Этап 3: AR-интеграция и дальнейшие улучшения – Финальный запланированный этап, нацеленный на инновационные возможности:
o	Дополненная реальность: Подключение модуля AR для просмотра работ. Например, интеграция с WebXR API или использованием платформы 8thWall. На этом этапе кнопка "Просмотр в AR" на странице работы получает реальное действие – при нажатии открывается камера устройства и работа отображается в пространстве (на стене комнаты пользователя) с реальными размерами. Потребуется подготовить соответствующие ресурсы: для картин – их изображение в нужном формате + данные о реальном размере для масштабирования, для скульптур – возможно 3D модель (GLTF/GLB) для отображения.
o	Проработка AR UX: Добавление подсказок для пользователя при входе в AR-режим (например, просьба покрутить телефон для калибровки, индикатор дистанции до стены, как сделано в проекте Saatchi Art8thwall.com, чтобы улучшить отслеживание без маркера).
o	Оптимизация производительности: AR-функционал требователен, поэтому необходимо убедиться, что основное приложение оптимизировано – внедрение код-сплиттинга, загрузки по требованию (ленивой загрузки) для тяжелых компонентов (например, модуль AR загружается только при нажатии кнопки).
o	Дополнительные языки (опционально): Если потребуется, добавление новых языков (в рамках i18n система это будет несложно – достаточно добавить файлы локализации и переводы).
o	Дополнительные улучшения: На основе отзывов пользователей и администратора – доработка UI/UX, возможное добавление новых разделов (например, новости или блог художника), интеграция рассылки на email (уведомление о новых работах, скидках), улучшение безопасности (двухфакторная аутентификация через Firebase, капча на формах и т.д.).
o	Финальное тестирование и деплой: Полный прогон всех сценариев (включая AR на различных устройствах), нагрузочное тестирование (особенно если ожидается большой трафик на AR или каталог), и развертывание финальной версии на продакшен (включая настройку CDN для изображений и скриптов, резервного копирования базы данных, мониторинга).
Каждый этап завершается контролем качества и презентацией промежуточного результата. Такой подход обеспечит последовательное наращивание возможностей сайта и своевременное выявление и устранение проблем.
Архитектура решения
Архитектура проекта предусматривает разделение на фронтенд (клиентскую часть) и бэкенд (серверную часть), с использованием облачных сервисов для отдельных функций (аутентификация и чат). Ниже описаны основные компоненты системы и взаимодействие между ними:
•	Фронтенд (клиентское приложение): Одностраничное приложение (SPA), разработанное на React. Фронтенд отвечает за отображение пользовательского интерфейса, обработку взаимодействия пользователя и выполнение запросов к серверу. При выборе технологии возможны два подхода: классическое SPA (например, с Create React App или Vite) или использование Next.js для серверного рендеринга (SSR) страниц. SSR может улучшить SEO и время первого отображения, что актуально для сайта художника (страницы работ могут лучше индексироваться поисковиками). Однако в рамках MVP можно начать с SPA. Код фронтенда организован в виде компонентов React, управление состоянием реализовано с помощью React Context API (например, для хранения текущего языка, темы и данных аутентифицированного пользователя) или сторонней библиотеки (Redux, если понадобится сложное состояние). Фронтенд будет взаимодействовать с бэкендом через REST API запросы (или GraphQL, но в данном ТЗ предполагается REST для простоты). Все чувствительные данные (например, токены Firebase) хранятся и обрабатываются на стороне клиента безопасно и никогда не вшиваются напрямую в HTML.
•	Бэкенд (серверное приложение): Сервер на Node.js с использованием фреймворка Express.js для обработки запросов от клиента. Бэкенд предоставляет REST API для основных операций: получение списка работ, фильтрация, получение деталей работы, аутентифицированные операции (оформление заказа, получение данных профиля, создание/редактирование работы – для админа и т.п.). Структура API разделена по логическим ресурсам: /api/artworks (каталог), /api/orders, /api/user, /api/admin и т.д. Каждый защищенный маршрут будет использовать middleware для проверки токена Firebase (подробнее об этом ниже в разделе об аутентификации). Бэкенд также будет выполнять бизнес-логику: например, расчет общей стоимости заказа (с учётом фиксированной доставки), проверка наличия товара на складе (в случае единичных работ – что она ещё не продана) и сохранение данных заказа. Для чата бэкенд может не требоваться, так как фронтенд общается напрямую с Firestore (Firebase) для обмена сообщениями, но при желании можно реализовать прокси через сервер для дополнительного контроля. Express-сервер также может служить точкой интеграции с внешними сервисами: например, вызывать API платежного шлюза при оформлении заказа. Поддержка HTTPS: для безопасности, особенно при работе с Firebase и платежами, приложение будет работать по HTTPS (на этапе разработки – через локальный сертификат или сервисы типа ngrok для отладки вебхуков платежей). Масштабируемость: при росте нагрузки бэкенд можно развернуть на облачных платформах (например, Heroku, AWS Elastic Beanstalk, Vercel/Nginx для Next.js, и т.п.) или использовать контейнеризацию (Docker + Kubernetes) – закладывается возможность горизонтального масштабирования, учитывая что состояние хранится во внешних базах (MongoDB, Firebase).
•	База данных (MongoDB): Внешняя NoSQL база данных MongoDB используется для хранения данных приложения – информации о работах, профилей пользователей, заказов и т.д. Выбор MongoDB обусловлен её гибкостью в работе с документами и простотой интеграции с JavaScript-стеком (MERN). Для доступа к MongoDB на стороне сервера используется ORM Mongoose, который позволяет определить схему (schema) для коллекций и работать с данными как с объектами. Данные, хранящиеся в MongoDB:
o	Работы (Artworks): Каждая работа хранится как документ с полями: название, описание, категория, год, размеры, цена, набор URL изображений, флаг доступности/продано и т.д. Поля, требующие локализации (например, название и описание), могут храниться либо как вложенный объект с языковыми ключами (например, title: { ru: "Название", en: "Title" }), либо как отдельные поля (title_ru, title_en). Будет выбрана оптимальная схема для удобства — вложенная структура позволяет легко добавлять новые языки.
o	Пользователи: Документы пользователей содержат firebaseUid (идентификатор пользователя из Firebase Auth, чтобы связать записи), имя, email, дату регистрации, роль (покупатель или администратор), а также профильные данные – например, адрес доставки, телефон и пр. (эти данные пользователь может заполнить в личном кабинете). Пароли и чувствительные данные в MongoDB не хранятся (аутентификация на Firebase), но может храниться ссылка на аватар или дополнительные настройки.
o	Заказы: Каждый заказ включает ссылку на пользователя, список приобретённых работ (ID работ, их названия, цена на момент покупки), сумму заказа, стоимость доставки, итоговую сумму, адрес доставки, статус заказа (новый, оплачен, отправлен, выполнен) и метаданные (дата создания и обновления). Важно сохранять копию цены и названия работы в момент покупки, чтобы отчёты оставались консистентными даже если данные работы потом изменятся.
o	Категории (опционально): Категории работ могут храниться отдельной коллекцией (с названием категории и порядком сортировки). Однако, если набор категорий невелик и фиксирован, можно обойтись без отдельной коллекции, а хранить категорию как строку в документе работы и использовать перечисления в коде.
o	Сообщения чата (если нужно в MongoDB): Первоначально чат реализован на Firestore, поэтому дублировать сообщения в MongoDB не требуется. В перспективе, можно хранить ссылки на диалоги или копии переписки и в MongoDB (например, для аналитики или истории), но это не является обязательной частью.
Дизайн схемы MongoDB стремится обеспечить баланс между нормализацией и денормализацией. Для ускорения выборок будут использованы индексы – например, на поле категории, цены, года в коллекции работ (чтобы эффективно выполнять фильтрацию), а также индекс по полю пользователя в коллекции заказов (для быстрого получения истории заказов конкретного пользователя). Все отношения между сущностями относительно просты: связь пользователь–заказы (один ко многим), категория–работы (один ко многим). В MongoDB такие связи можно хранить с помощью идентификаторов (напр., в заказе хранить userId, а при выводе детали заказа делать дополнительный запрос за данными пользователя).
•	Аутентификация и безопасность (Firebase Auth + Firebase Admin): Процесс авторизации построен на Firebase Authentication. На фронтенде интегрируется Firebase SDK, который позволяет пользователю зарегистрироваться и войти (изначально предусмотрена стандартная регистрация по email и паролю; при желании можно добавить OAuth-провайдеров – Google, Facebook и т.п., Firebase это поддерживает). Firebase Auth управляет хранением учетных записей, восстановлением пароля и т.д., что снижает трудозатраты на реализацию этих функций с нуля. После входа пользователя Firebase выдает ID токен (JWT), который подтверждает его личность. Этот токен отправляется с каждым защищенным запросом к бэкенду (например, в заголовке Authorization: Bearer <token>). На стороне сервера используется Firebase Admin SDK (со служебным ключом от Firebase) для проверки подлинности токена. Проверка токена осуществляется через метод admin.auth().verifyIdToken(token), который возвращает информацию о пользователе, если токен валиденstackoverflow.com. Таким образом, сервер удостоверяется, что запрос исходит от аутентифицированного пользователя, и может получить его UID. Далее UID используется, чтобы связать запрос с данными пользователя в MongoDB (например, найти профиль или определить права доступа). В зависимости от роли пользователя (обычный или администратор) сервер применяет разные политики:
o	Обычный пользователь: имеет доступ только к операциям от своего имени – просмотр каталога, оформление своего заказа, просмотр/редактирование своего профиля, отправка сообщений в чат.
o	Администратор: обладает расширенными правами – может получать списки всех заказов, всех пользователей, добавлять/редактировать работы, отвечать в чате от имени администратора. Роль администратора задается либо в MongoDB (поле role: "admin" у пользователя), либо дополнительно дублируется как кастомный клейм в Firebase Auth (после создания учетной записи художника вручную можно назначить ей custom claim "admin" через Firebase Admin SDK). В рамках MVP достаточно проверки через базу: например, middleware на сервере после verifyIdToken может искать пользователя в MongoDB и проверить поле роли. Если роль не админ – возвращать ошибку для эндпоинтов админки.
o	Безопасность: Использование Firebase Auth устраняет необходимость самостоятельно хранить пароли; тем не менее, сервер должен быть защищен от несанкционированных обращений. Каждый защищенный маршрут оборачивается проверкой токена. Также будут настроены CORS-политики на сервере, чтобы только фронтенд сайта мог вызывать API. Firebase Auth обеспечивает и управление сессией – токены имеют ограниченный срок жизни (~1 час), после чего автоматически обновляются. На фронтенде используется отслеживание изменения состояния (onAuthStateChanged) для реакции на логаут или обновление токена.
•	Хранилище медиа (изображения работ): Большие изображения картин и фотографий работ целесообразно хранить вне самой базы данных, чтобы не перегружать MongoDB. Возможные решения – Firebase Storage, Amazon S3 или другой CDN. Например, можно использовать Firebase Storage, так как Firebase уже используется для Auth и Firestore: загрузка изображений работ при их добавлении администратором будет идти в Firebase Storage, откуда получаются публичные ссылки. Эти ссылки сохраняются в поле images документа работы в MongoDB. При отображении каталога фронтенд загружает изображения по URL напрямую с CDN, что разгружает наш бэкенд. Важным аспектом будет оптимизация изображений – генерация превью или уменьшенных копий для списка, ленивая загрузка (lazy load) изображений вне экрана и т.д., чтобы страница каталога быстро отображалась.
•	Реальный время чат (Firebase Firestore): Для реализации чата выбрано использование Firebase Cloud Firestore – облачной NoSQL базы данных с поддержкой мгновенной синхронизации данных. Когда пользователь отправляет сообщение через интерфейс сайта, фронтенд добавляет документ в соответствующую коллекцию Firestore (например, chats/{userId}/messages). Firestore мгновенно сообщает о добавлении всем подписанным клиентам. У пользователя фронтенд будет подписан (через onSnapshot) на изменения в коллекции его диалога, чтобы отобразить ответ администратора в реальном времени. Администратор (на этапе MVP – через консоль Firebase, а на этапе 2 – через админ-панель) также подписан на обновления и может отправлять ответы, добавляя сообщения от своего имени. Firestore обеспечивает реактивность: разработчику не нужно вручную опрашивать сервер, новые сообщения появляются на клиентах автоматическиfreecodecamp.org. Структура данных для чата:
o	Коллекция chats (или messages): может быть организована по-разному. Оптимально — создать подколлекции для каждого диалога. Например, chats/{userId}/messages – где {userId} – UID пользователя (либо генерируется отдельный chatId). В подколлекции messages хранятся документы сообщений с полями: sender (значения: "user" или "admin"), text (текст сообщения), timestamp (время отправки), возможно read (прочитано админом).
o	Правила безопасности Firestore будут настроены так, чтобы пользователь имел доступ только к своей подколлекции сообщений (по UID, совпадающему с его auth-UID) – это обеспечивается встроенными правилами Firebase. Администратор (идентифицируется по UID или кастомному claim) будет иметь доступ ко всем коллекциям, либо мы организуем для него отдельное веб-приложение/раздел с привилегиями.
o	Пример записи сообщения в Firestore (на стороне фронтенда, с использованием Firebase SDK):
o	// Добавление нового сообщения в чат
o	import { collection, addDoc, serverTimestamp } from "firebase/firestore";
o	...
o	const messagesRef = collection(firestore, "chats", currentUser.uid, "messages");
o	await addDoc(messagesRef, {
o	  sender: "user",
o	  text: messageText,
o	  timestamp: serverTimestamp()
o	});
Дальше, у обоих сторон настроен слушатель:
import { onSnapshot, query, orderBy } from "firebase/firestore";
...
useEffect(() => {
  const q = query(messagesRef, orderBy("timestamp"));
  const unsubscribe = onSnapshot(q, (snapshot) => {
    // обновление локального состояния списка сообщений
    setMessages(snapshot.docs.map(doc => doc.data()));
  });
  return unsubscribe;
}, []);
Таким образом, каждое новое сообщение в базе вызывает обновление UI практически мгновенно.
•	Использование готового облачного решения для чата позволяет избежать написания собственного WebSocket-сервера. Это ускоряет разработку и масштабирование: Firestore сам справляется с большим количеством соединений. В случае роста нагрузки и затрат можно в будущем мигрировать на собственное решение (например, Socket.io + Redis), но для данного проекта это вряд ли потребуется.
•	Внешние сервисы и интеграции: В состав системы входят и сторонние сервисы:
o	Firebase – как описано, для Auth и Firestore (и Storage для файлов). Firebase проект необходимо настроить через консоль: включить нужные методы входа (Email/Password, иные по необходимости), настроить базовые правила безопасности Firestore (например, чтобы неавторизованные не могли писать в коллекции чата), создать Service Account для серверной верификации токенов.
o	Платёжный шлюз (на этапе интеграции): Предполагается использование Stripe. Интеграция Stripe заключается во взаимодействии бэкенда с их API – например, при оформлении заказа наш сервер будет вызывать Stripe Checkout Session API, передавать сумму и описание заказа, получать ответ (ссылку на оплату или статус) и перенаправлять пользователя на хостинг Stripe для ввода карты, либо использовать виджет. После оплаты Stripe делает webhook-запрос на наш сервер для подтверждения, и мы обновляем статус заказа в базе. На время отсутствия реальной интеграции (MVP) эти шаги будут эмулированы – при нажатии "Оплатить" заказ сразу помечается как "требующий подтверждения" или "оплаченный" (в зависимости от модели, можно сделать просто сразу успешным для простоты, либо добавить шаг "оплатить позже").
o	Хостинг и развертывание: Для фронтенда возможно использовать хостинг статических файлов (если SPA) – например, Firebase Hosting, Vercel (если Next.js) или Netlify. Бэкенд (Node.js) можно развернуть на Heroku, Railway или аналогичном сервисе. Базу данных MongoDB целесообразно использовать облачную (MongoDB Atlas) – с ней легко подключиться из любого облака. Также нужно учесть настройку переменных окружения: URL базы, конфиги Firebase (API key, etc.), секретные ключи Stripe и другие – они не должны быть в репозитории.
o	Аналитика и мониторинг: По желанию, можно встроить Google Analytics или Яндекс Метрику для сбора статистики посещений, а для мониторинга ошибок фронтенда – Sentry. Эти вещи не указаны в требованиях, но могут быть добавлены в финальных этапах для повышения качества продукта.
Взаимодействие компонентов в целом происходит следующим образом: браузер загружает React-приложение (статические бандлы) → при действиях пользователя (например, открытие каталога) React вызывает API бэкенда (GET запрос на /api/artworks) → сервер Express обращается к MongoDB, получает данные и возвращает JSON с данными работ → React отображает их. Если пользователь логинится, то через Firebase Auth получает токен и сохраняет его; при дальнейшем запросе, например, оформления заказа, React отправляет POST на /api/orders с заголовком авторизации токена → сервер через Firebase Admin проверяет токен, идентифицирует пользователя, затем записывает заказ в MongoDB и возвращает ответ. Реaltime-функции (чат) минуют наш сервер: React напрямую пишет/читает Firestore, но при этом Firebase Auth автоматически ограничивает доступ к данным по правилам (UID). Архитектура такого гибридного типа сочетает сильные стороны нескольких технологий: простоту разработки и богатые возможности Firebase для auth и realtime, а также мощь MongoDB для гибкого хранения данныхtempmail.us.com, где требуются сложные запросы (фильтрация по цене, сортировка по году и т.д.) и транзакционная логика (управление заказами). Такая связка – Firebase Auth + собственный сервер + MongoDB – уже зарекомендовала себя как надёжная и масштабируемаяmongodb.comtempmail.us.com.
Реализация интерфейса (Frontend UI)
Интерфейс пользователя будет реализован как одностраничное React-приложение, что обеспечит богатый интерактивный опыт: быстрые переходы между разделами без перезагрузки страницы, мгновенные фильтры, динамические эффекты. Дизайн – тёмная тема с акцентом на визуальный контент. Рассмотрим основные страницы и компоненты, а также подходы к их реализации.
Основные страницы и компоненты
•	Главная страница: Первая страница, которую видит посетитель. Она задаёт настроение и стиль. В верхней части – крупный герой-блок: возможно, полноэкранное фоновое изображение или слайдер с лучшими работами художника, наложенный логотип/имя художника и краткий слоган. На тёмном фоне герой-изображение будет смотреться контрастно. Далее может следовать короткий раздел "О художнике" (пару предложений и кнопка "Подробнее", ведущая на соответствующую страницу) и, например, превью каталога (несколько избранных работ в сетке с кнопкой "Смотреть все работы"). Главная страница может также содержать блок с ближайшими событиями/выставками или новостями, если актуально. Навигация (шапка сайта) – фиксированная сверху, содержит логотип или имя художника и меню (Каталог, О художнике, Контакты, переключатель языка, иконки темы и личного кабинета). Футер – контактная информация, ссылки на соцсети.
•	Каталог работ: Страница со списком всех доступных работ. Здесь будет панель фильтров и галерея превью работ. Фильтры, скорее всего, размещаются в боковой колонке слева (если дизайн позволяет) либо в виде выпадающих списков/кнопок сверху на небольших экранах. Фильтры включают:
o	Категория: список чекбоксов или тегов (например, "Живопись", "Скульптура", "Графика"...).
o	Размер: возможно, предустановленные диапазоны или категории (например, "маленькие, средние, большие") или фильтр по габаритам (в сантиметрах).
o	Цена: ползунок диапазона цены (от минимальной до максимальной) либо поля ввода для min-max.
o	Год: либо диапазон (с - по), либо список отдельных лет/десятилетий.
При изменении фильтров список работ обновляется. Технически это можно реализовать двумя способами:
1.	Фронтенд запрашивает все работы разом при загрузке страницы и затем фильтрует их на клиенте (подходит если работ немного, < ~100).
2.	Фронтенд делает запрос к серверу с параметрами фильтра (например, GET /api/artworks?category=painting&priceMax=10000&yearFrom=2015) и сервер возвращает уже отфильтрованные результаты. Второй подход масштабируемый – можно использовать возможности MongoDB по фильтрации и индексам на поля цены, года и т.д. Мы планируем реализовать серверную фильтрацию для эффективности. При каждом изменении фильтра можно делать новый запрос, либо обновлять результаты по кнопке "Применить фильтр". Используя React, состояние фильтров хранится в useState/useReducer, и при изменении с небольшим дебаунсом выполняется fetch к API.
Список работ отображается сеткой карточек. Лучше всего подойдет адаптивная сетка с авто-подбором количества столбцов (CSS Grid или Flex-wrap): например, 4 колонки на большом экране, 2-3 на планшете, 1 на мобильном. Изображения работ могут иметь разные пропорции, поэтому стоит предусмотреть или квадратные превью (обрезка/паддинг), или же использовать masonry-стиль (различная высота строк). Для простоты можно начать с фиксированной высоты превью (кроп по центру). Каждая карточка работы содержит: уменьшенное изображение, название работы, возможно цену. При наведении могут появляться дополнительные элементы – например, значок быстрого просмотра или просто эффект затемнения/подсветки. Клик по карточке ведет на страницу детали работы.
Пример реализации карточки работы в виде React-компонента:
import React from 'react';
import './ArtworkCard.css'; // стили карточки

function ArtworkCard({ artwork, onClick }) {
  return (
    <div className="artwork-card" onClick={onClick}>
      <div className="thumb">
        <img src={artwork.thumbnailUrl} alt={artwork.title} loading="lazy" />
      </div>
      <div className="info">
        <h3>{artwork.title}</h3>
        {artwork.price && <p className="price">{artwork.price} ₽</p>}
      </div>
    </div>
  );
}

export default ArtworkCard;
Здесь artwork.thumbnailUrl – URL до уменьшенного изображения (можно генерировать при загрузке оригинала), artwork.title – локализованное название (например, в зависимости от текущего языка выбрать artwork.title_ru или title.en). Компонент используется в сетке, например:
<div className="artwork-grid">
  {artworks.map(item => (
    <ArtworkCard key={item._id} artwork={item} onClick={() => openDetails(item._id)} />
  ))}
</div>
Стили .artwork-card задают фон, паддинги; .thumb img — делают изображение адаптивным (max-width: 100%, height: auto). Также можно реализовать интересный hover-эффект через CSS, например плавное увеличение картинки или наложение цвета.
•	Страница детали работы: Здесь пользователь видит всю информацию о выбранной работе и может оформить ее покупку. Основной компонент – галерея изображений работы. Если есть несколько фото (например, общий вид, крупные планы), предоставляем либо слайдер (переключение между изображениями), либо возможность открыть изображение на весь экран (lightbox). На странице выводится:
o	Название работы (локализованное).
o	Описание работы – текст, рассказ о работе, техника, идея (тоже в зависимости от языка).
o	Характеристики: год создания, размеры (например, "50x70 см"), материал/техника (если релевантно), категория, и т.д., оформленные списком или таблицей.
o	Цена работы. Если работа уже продана, вместо цены отображается пометка "Продано".
o	Кнопка "Добавить в корзину" или "Купить". Поскольку продаются, вероятно, уникальные оригиналы, можно вместо многоэлементной корзины сделать сразу "Купить сейчас". Однако, поскольку в ТЗ явно упомянута корзина, реализуем классический вариант: добавление в корзину (всплывает уведомление "Добавлено" и т.д.). Если работа одна в наличии, после добавления в корзину можно либо пометить ее как зарезервированную (чтобы другой не смог добавить, но для MVP можно не усложнять).
o	Кнопка "Посмотреть в AR" (планируется на будущее). Сейчас она может быть видна, но не активна, либо доступна, если для этой работы есть AR-контент. Нажатие может открывать модальное окно с инструкцией "Эта функция в разработке" либо, если внедрено – переходить в AR-режим.
o	Кнопка "Задать вопрос". Альтернативно, можно встроить чат в эту же страницу: например, значок чата, по нажатию открывается окно чата (внизу или всплывающее) с администратором. Это обеспечит быструю связь ("уточнить детали по работе").
Разметка страницы работы может быть такой:
<div className="artwork-detail">
  <div className="gallery">
    {/* Компонент галереи изображений */}
    <ImageGallery images={artwork.images} />
    { /* Вспомогательный компонент: миниатюры, стрелки навигации и пр. */ }
  </div>
  <div className="details">
    <h1>{artwork.title}</h1>
    <p className="desc">{artwork.description}</p>
    <ul className="meta">
      <li><b>Год:</b> {artwork.year}</li>
      <li><b>Размер:</b> {artwork.size}</li>
      <li><b>Категория:</b> {artwork.category}</li>
      {/* и т.д. */}
    </ul>
    {artwork.price && !artwork.sold ? (
      <>
        <div className="price">{artwork.price} ₽</div>
        <button onClick={addToCart}>Добавить в корзину</button>
      </>
    ) : (
      <div className="sold-out">Продано</div>
    )}
    <div className="actions">
      <button className="ar-button" disabled /* пока не работает */>
        Посмотреть в AR
      </button>
      <button className="chat-button" onClick={openChat}>
        Написать вопрос
      </button>
    </div>
  </div>
</div>
Компоненты ImageGallery, ChatWidget и т.д. разрабатываются отдельно. Важна адаптивность: на мобильных устройствах галерея может занимать весь экран сверху, а детали идти ниже; на широких экранах – галерея слева, детали справа.
•	Страница "О художнике": Статическая страница с биографией, информацией об авторе. Здесь обычно размещается фотография художника, текст о творческом пути, выставках, достижениях. Возможно, список/сеточка с логотипами или названиями выставок, наград. Этот раздел не требует сложной логики, но должен быть локализован (две языковые версии текста). Реализуется как простой React-компонент с разметкой. Желательно стилизовать его в общем стиле сайта: тёмный фон, светлый текст, акценты (например, цитаты или подписи) выделены стилистически. Если текст большой, стоит разбить на подзаголовки, добавить интерактивности – галерею фотографий или видео (например, интервью, рабочий процесс). Можно предусмотреть возможность редактирования этого раздела через админ-панель (например, хранить содержимое в MongoDB или в файле), но на первых этапах достаточно захардкодить текст или хранить в JSON файлах локализации.
•	Страница "Контакты": Здесь предоставляются способы связи с художником или его студией. Обычно включает: адрес мастерской или галереи (если есть публичный), email, телефон, ссылки на соцсети. Также можно встроить форму обратной связи (где пользователь может отправить сообщение, например, для заказа персональной работы или общего вопроса). Такая форма – это отдельный функционал (отправить email или записать заявку в базу). В рамках MVP можно просто показать контакты. Дизайн: в контактах можно вывести карту (Google Maps или Яндекс.Карты) с отметкой, если нужен адрес. Форма обратной связи (если делается) – несколько полей (имя, email, сообщение) и капча. Обработка может идти через тот же чат либо через отправку на почту администратора (например, с использованием Email API на бэкенде). В MVP можно реализовать форму, которая сохраняет сообщение в коллекцию "requests" в MongoDB, и админ сможет прочитать и ответить вручную.
•	Личный кабинет пользователя: Доступен только авторизованному пользователю (после Firebase Login). Сюда ведет иконка профиля на навбаре. В кабинете отображаются:
o	Приветствие, имя пользователя (из профиля).
o	Возможно, возможность сменить язык интерфейса (но это дублируется переключателем на сайте).
o	Информация профиля: email (неизменяемый, либо опционально добавить изменение через Firebase), поля для ввода/редактирования адреса доставки, телефона и прочих деталей, необходимых для оформления заказа по умолчанию.
o	История заказов: список заказов пользователя из MongoDB. Каждый заказ – дата, список названий работ, сумма, статус (например, "В обработке", "Отправлен 12.09.2025" и т.д.). При желании, можно сделать, чтобы клик по заказу раскрывал подробности (адрес доставки, состав).
o	Доступ к чату: здесь же может быть видна история переписки с администратором (если интегрировать чат в кабинет). Например, вкладки "Мои заказы" и "Сообщения". Либо можно реализовать чат как глобальный виджет, доступный на любой странице (например, иконка мессенджера всегда в уголке).
o	Выход из аккаунта: кнопка "Выйти", выполняющая firebase.auth().signOut() и сброс локального состояния, с перенаправлением на главную или страницу входа.
Личный кабинет требует защиты маршрута: если неавторизован – редирект на страницу входа. Реализуется через компонент <PrivateRoute> или с помощью проверки в React Router. Firebase предоставляет метод onAuthStateChanged для глобального слежения, можно использовать контекст AuthContext чтобы хранить currentUser.
•	Страница входа/регистрации: Так как используется Firebase, можно воспользоваться их готовыми UI компонентами (FirebaseUI Auth) или сделать собственные формы. В простейшем случае – одна страница Login с табами "Войти" и "Регистрация". Поля: email, пароль, и (для регистрации) подтверждение пароля. При сабмите вызывается Firebase Auth (метод signInWithEmailAndPassword или createUserWithEmailAndPassword). Обработка ошибок (неверный пароль, пользователь не найден, слабый пароль при регистрации и т.д.) – отображение сообщений. После успешного входа – перенаправление в личный кабинет или на ту страницу, откуда пришел пользователь.
Можно предложить и альтернативные методы: вход через Google одним кликом (signInWithPopup(provider)), это легко добавить через Firebase. В дизайне стоит минималистично: пара инпутов, кнопка, всё на тёмном фоне (может быть эффект размытия фона, если форма всплывающая). Но приоритет – функциональность.
•	Админ-панель: Отдельный раздел, доступный только админу. Может быть реализован как отдельное приложение или как часть той же SPA с маршрутом /admin. Для простоты реализуем внутри основной React-аппликации, используя тот же бэкенд. При входе под админом (распознаётся по UID или claim), переход на /admin станет доступен.
o	Главная панель администратора: может содержать краткий обзор – количество работ в каталоге, новых сообщений, новых заказов (dashboard с цифрами).
o	Управление работами: страница со списком всех работ (таблица или карточки). Для каждой – действия: редактировать, удалить. Рядом кнопка "Добавить работу". При редактировании/добавлении – форма, где админ вводит название (на русском и английском), описание (на двух языках, возможно многострочное поле), цену, категорию (выбирает из списка или вводит новую), год, размер, загружает изображения (можно несколько). Загрузка изображений – через элемент <input type="file" multiple>; при сабмите изображения сначала загружаются, например, в Firebase Storage (через Firebase SDK в браузере, либо отправляются на наш сервер, который сохранить в облако – выберем проще: можно напрямую использовать Firebase Storage SDK на клиенте для загрузки, получить URL и включить в форму). После сохранения работы, она появляется в каталоге пользователям.
	Технически, можно реализовать через вызовы API: фронтенд отправляет POST /api/artworks с JSON данными (название, описание и пр.) и URL-ами изображений (после загрузки их в Storage). Сервер верифицирует что запрос от админа, затем создает документ в MongoDB. Аналогично PUT /api/artworks/:id для обновления, DELETE /api/artworks/:id для удаления. Удаление изображения из Storage при удалении работы желательно, но можно отложить (или помечать).
o	Управление заказами: страница, где администратор видит все заказы. Таблица с колонками: № заказа (ID), дата, клиент (имя/email), сумма, статус. Можно отсортировать по дате. Клик на заказ – открывает детали: список работ, адрес доставки, контакт клиента, и блок изменения статуса. Админ может пометить заказ как отправленный (ввести трек-номер, если есть), как выполненный и т.д. Это обновляет запись в MongoDB. Также здесь может быть кнопка "Связаться с покупателем" – которая, к примеру, открывает чат с этим пользователем (переключает на раздел сообщений и выбирает нужный диалог).
o	Чат с пользователями: интерфейс для общения. Либо реализован общей лентой (но если много пользователей, смешивать не стоит). Правильнее – список диалогов слева (по имени/email пользователя или номеру заказа, если чат привязан к заказу?), и окно чата справа – классический мессенджер интерфейс. При выборе конкретного пользователя, админ видит всю историю сообщений с ним (подгружается из Firestore, запрос chats/{userId}/messages). Админ может ввести сообщение и отправить – это добавит документ с sender: "admin" в ту же коллекцию. Пользователь получит его в своем чате практически мгновенноfreecodecamp.org. Необходимо, чтобы админ приложение аутентифицировалось в Firebase как админ. Можно либо использовать ту же веб-авторизацию (Firebase Auth) – т.е. художник заходит на сайт, логинится как обычный пользователь но с ролью админ, и мы используем его токен, который будет успешно позволять читать/писать во все чаты (по правилам security). Либо завести сервисный аккаунт – но в веб-клиенте это не безопасно. Так что используем первый вариант: admin в клиенте тоже Firebase-авторизован.
o	Управление контентом: Можно добавить секцию для редактирования статических страниц ("О художнике", "Контакты"). Например, форма с полем "О художнике (RU)" и "О художнике (EN)" – сохранение обновит документ в базе или JSON файл, а фронтенд будет подтягивать оттуда. Это облегчит обновление информации через админку без правки кода.
Для реализации админ-панели по-быстрому можно использовать UI-библиотеку (например, Ant Design, MUI) – она даст готовые компоненты таблиц, форм, модальных окон, что ускорит работу. В то же время, основная пользовательская часть сайта можно быть более уникальной по дизайну. Разделение стилей: возможно, админку оформить нейтрально (светлая или тёмная, но более стандартный интерфейс), тогда как публичный сайт – художественно. В рамках единого приложения можно иметь две темы оформления или просто совершенно другой набор стилей для /admin. Это вопрос дизайна.
Обязательна проверка доступа: если обычный пользователь случайно попадает на /admin – ему должен показываться 404 или редирект на главную. Это легко сделать в Router, проверяя currentUser.role.
Темная тема и переключение темы
Сайт изначально спроектирован в темной цветовой схеме, которая соответствует авангардной эстетике и выгодно представляет искусство (темный фон делает цвета работ более контрастными). Важно правильно реализовать тёмный режим с точки зрения UX: не использовать абсолютно черный цвет #000000 для фона, поскольку чисто черный с белым текстом создаёт излишний контраст и напрягает глазаapp.uxcel.com. Рекомендуется использовать очень тёмно-серый оттенок, например #121212 (это совет Material Design для dark modeapp.uxcel.com) или #1E1E1E, чтобы фон был чуть мягче. Текст, вместо чисто белого, тоже может быть слегка сероватым (#E0E0E0) для комфортного чтения. Также в темной теме важно подобрать акцентные цвета (например, ярко-оранжевый или кислотно-зелёный для выделения элементов авангардного стиля) и проверить их контрастность на темном фоне.
Хотя тёмная тема – основная, предусмотрим переключатель темы на сайте, чтобы пользователь при желании мог включить светлую тему. Это полезно для юзабилити, т.к. не всем комфортно читать светлый текст на тёмном фоне, особенно днёмapp.uxcel.com. Переключатель (иконка луны/солнца) обычно размещается в шапке сайта. При нажатии – тема переключается и этот выбор сохраняется (например, в localStorage), чтобы при следующем визите использовать последнюю выбранную тему.
Техническая реализация переключения темы:
•	Можно использовать CSS-переменные (custom properties) для цветов. В :root определить набор переменных для светлой и темной темы, и при переключении добавлять к <body> класс .theme-dark или .theme-light, с переопределением этих переменных.
•	Альтернативно, подключить две CSS темы и переключать ссылку на стилевой файл, но с React проще использовать первый подход или библиотеку управления темами (styled-components ThemeProvider, MUI themes, etc.).
•	Пример: в CSS:
•	:root {
•	  --bg-color: #ffffff;
•	  --text-color: #000000;
•	  --accent-color: #FF5500;
•	  /* ... */
•	}
•	.theme-dark {
•	  --bg-color: #121212;
•	  --text-color: #E0E0E0;
•	  --accent-color: #FF5500;
•	}
•	body {
•	  background-color: var(--bg-color);
•	  color: var(--text-color);
•	}
В React при монтировании приложения читаем из localStorage preferedTheme. Если не задано – можно определить по системным настройкам (в современных браузерах prefers-color-scheme), но можно и дефолтно темную тему. Затем устанавливаем класс к <html> или <body>.
Напишем небольшой React-хук или компонент переключателя:
import { useEffect, useState } from 'react';

const DarkModeToggle = () => {
  const [darkMode, setDarkMode] = useState(false);
  useEffect(() => {
    // при монтировании - прочитать сохраненную тему
    const savedTheme = localStorage.getItem('theme');
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
      setDarkMode(true);
      document.documentElement.classList.add('theme-dark');
    }
  }, []);
  
  const toggleDarkMode = () => {
    const newMode = !darkMode;
    setDarkMode(newMode);
    if (newMode) {
      document.documentElement.classList.add('theme-dark');
      localStorage.setItem('theme', 'dark');
    } else {
      document.documentElement.classList.remove('theme-dark');
      localStorage.setItem('theme', 'light');
    }
  };

  return (
    <button onClick={toggleDarkMode} aria-label="Toggle dark mode">
      {darkMode ? '🌙' : '☀️'}
    </button>
  );
};
Здесь при переключении мы добавляем/удаляем класс theme-dark на элемент <html> (или <body>). Иконку можно условно отобразить: если сейчас темная – показать значок луны (значит нажимая, перейдем в светлую), иначе солнца. Этот компонент включается в шапку сайта наряду с переключателем языка.
С поддержкой двух тем нужно проверить все элементы дизайна – во светлой теме фон станет светлым, текст темным, и нужно убедиться, что картинки (многие из которых с темным фоном) будут нормально смотреться. Также SVG-иконки или изображения логотипа могут потребовать инвертированных версий для светлой темы.
Мультиязычность и локализация
Поддержка двух языков (RU/EN) будет реализована через механизм интернационализации (i18n). В React экосистеме есть популярная библиотека react-i18next (обертка над i18next), которая позволит удобно организовать переводы. Принцип работы:
•	Заводится каталог переводов – обычно набор JSON-файлов по языкам. Например, locales/en.json и locales/ru.json. В них хранятся ключи и текст. Структура может повторять структуру страниц. Например:
•	// en.json
•	{
•	  "nav": {
•	    "home": "Home",
•	    "catalog": "Catalog",
•	    "about": "About",
•	    "contacts": "Contacts",
•	    "admin": "Admin Panel"
•	  },
•	  "home": {
•	    "welcome": "Welcome to the gallery of <1>{{artistName}}</1>!",
•	    "cta_view": "View Catalog"
•	  },
•	  "artwork": {
•	    "year": "Year",
•	    "size": "Dimensions",
•	    "category": "Category",
•	    "price": "Price",
•	    "sold": "Sold",
•	    "add_to_cart": "Add to cart",
•	    "buy_now": "Buy Now",
•	    "view_in_ar": "View in AR",
•	    "ask": "Ask a Question"
•	  }
•	  // ... etc
•	}
•	// ru.json
•	{
•	  "nav": {
•	    "home": "Главная",
•	    "catalog": "Каталог",
•	    "about": "О художнике",
•	    "contacts": "Контакты",
•	    "admin": "Админ-панель"
•	  },
•	  "home": {
•	    "welcome": "Добро пожаловать в галерею <1>{{artistName}}</1>!",
•	    "cta_view": "Смотреть каталог"
•	  },
•	  "artwork": {
•	    "year": "Год",
•	    "size": "Размер",
•	    "category": "Категория",
•	    "price": "Цена",
•	    "sold": "Продано",
•	    "add_to_cart": "Добавить в корзину",
•	    "buy_now": "Купить сейчас",
•	    "view_in_ar": "Просмотреть в AR",
•	    "ask": "Задать вопрос"
•	  }
•	}
Здесь <1>{{artistName}}</1> показывает, что библиотека позволяет внедрять переменные и даже React-компоненты в строки (например, имя художника обернуть тегом <1>…</1> для стилизации).
•	В корневом компоненте (App) подключается i18next: указываются ресурсы (или путь до файлов, можно загрузкой), и инициализируется с языком по умолчанию и fallback-языком (на случай отсутствия перевода). Например:
•	import i18n from 'i18next';
•	import { initReactI18next } from 'react-i18next';
•	import en from './locales/en.json';
•	import ru from './locales/ru.json';
•	
•	i18n
•	  .use(initReactI18next)
•	  .init({
•	    resources: { en: { translation: en }, ru: { translation: ru } },
•	    lng: 'ru',
•	    fallbackLng: 'en',
•	    interpolation: { escapeValue: false }
•	  });
(Можно подключить и LanguageDetector, чтобы автоматически выбрать язык по браузеру пользователя).
•	В компонентах используется хук useTranslation() для получения функции t. Пример:
•	import { useTranslation } from 'react-i18next';
•	...
•	const { t } = useTranslation();
•	return (
•	  <nav>
•	    <a href="/">{t('nav.home')}</a>
•	    <a href="/catalog">{t('nav.catalog')}</a>
•	    ...
•	    <LanguageSwitcher /> {/* компонент переключения языка */}
•	  </nav>
•	);
Переключатель языка изменяет текущую локаль: i18n.changeLanguage('en') или 'ru'. Это автоматически приведет к обновлению всех t() на странице (через механизм context).
Важным моментом является локализация данных. Интерфейсные фразы мы перевели, но что насчет названий и описаний работ? Эти данные могут прийти из MongoDB уже на нужном языке. Подходы:
•	Хранить в базе сразу два поля, как упомянуто (title_en, title_ru, description_en, description_ru). Тогда API можно возвращать оба, а на клиенте выбирать нужное. Или даже возвращать только нужное, если API знать язык (например, GET /api/artworks?lang=ru).
•	Локализовать на клиенте через i18n: т.е. хранить в базе ключи, а тексты всех описаний тоже зашить в файлы локализации. Это неудобно для наполнения (админу придется редактировать JSON с переводами). Лучше хранить тексты в базе, а i18n использовать только для статических UI.
Мы выберем хранение текстов работ в базе в обоих вариантах, а API будет возвращать оба языка или, например, в структуре:
{
  "_id": "...",
  "title": {"ru": "Название", "en": "Title"},
  "description": {"ru": "описание...", "en": "description..."},
  "price": 10000,
  ...
}
На клиенте можно обернуть, например, в функцию getLocalized(artwork.title) которую в зависимости от текущего языка вернет нужную строку.
Переключение языка на сайте должно переключать весь видимый текст, включая и загруженные данные. Это означает, что, например, список работ, полученный от сервера, содержит данные на обоих языках, и при переключении языка мы можем без нового запроса отрендерить другой язык описаний. Но некоторые вещи (например, фильтр по категориям) – категории тоже надо перевести. Категории можно хранить либо тоже в объекте с языками, либо фиксированно на английском и переводить через i18n (например, ключи category.painting -> "Живопись").
Проверим, что все элементы локализованы: кнопки, меню, статические тексты, сообщения об ошибках ("не найдено", "заполните поле" и т.д.).
Сетка и адаптивность дизайна
Для художественного сайта визуальная подача критически важна. Использование CSS Grid Layout позволит создать интересные композиции из изображений. Например, на главной странице можно расположить несколько изображений в асимметричной сетке (авангард любит нестандартные раскладки) – CSS Grid с именоваными областями поможет этого достичь. Однако, не стоит жертвовать удобством ради креативности: все изображения должны быть достаточно крупными и легко просматриваться.
Адаптивный дизайн: сайт должен корректно отображаться и на больших десктопах, и на мобильных устройствах. Это означает перестройку макета:
•	На мобильном меню превращается в кнопочку (гамбургер) – можно использовать готовые решения или небольшое собственное: при клике показывать вертикальное меню.
•	Сетка работ на каталоге – 1 колонка на смартфоне (чтобы фото были крупные, на всю ширину), 2 на планшете, 3-4 на десктопе.
•	Фильтры на каталоге – если экран узкий, фильтры можно поместить в выпадающее меню или отдельную панель, открывающуюся кнопкой "Фильтры".
•	Страница работы – галерея изображений, возможно, превращается в свайп-компонент (для удобства листания на тачскрине), характеристики можно свернуть в аккордеон.
•	Шрифты и интервалы – нужно проверить читабельность на разных экранах, возможно, использовать относительные единицы (vw, проценты) или CSS clamp() для масштабирования текста от мобильного к десктопу.
Grid в каталоге: стоит учитывать, что изображения могут быть разного размера и ориентации. Чтобы сетка выглядела аккуратно, можно:
•	Привести превью к единому размеру контейнера (например, квадраты 300x300) и использовать object-fit: cover для <img> чтобы заполнить квадрат, обрезав лишнее. Так получится ровная сетка.
•	Либо построить мозаичную сетку (masonry), но CSS Grid не поддерживает auto-flow по плотной сетке в две оси. Можно либо использовать Masonry плагин (например, Masonry.js) или CSS columns. Но Masonry может усложнить, на MVP лучше ровная сетка.
•	Еще вариант: варьировать размер карточек для художественного эффекта (например, какая-то карточка двойного размера). Это можно сделать grid-свойствами (grid-row/column span). Но это ручная работа – можно предусмотреть флаг в данных "highlighted" для некоторых работ, чтобы делать их карточку больше.
Lazy loading изображений: Использование атрибута loading="lazy" на <img> (как в примере ArtworkCard) позволит не загружать картинки, пока они не появляются в области просмотра – это улучшит скорость загрузки страницы каталога.
Буферизация и оптимизация: Для очень больших изображений (оригиналов) – нужно либо генерировать уменьшенные версии для превью (как упомянуто), либо использовать <img srcset> с несколькими размерами. Например, <img src="/images/work123_small.jpg" srcset="/images/work123_medium.jpg 768w, /images/work123_large.jpg 1200w" sizes="(max-width: 600px) 90vw, (min-width: 601px) 30vw, ...">. Это даст браузеру выбрать подходящее качество под устройство.
Вёрстку будем проверять в современных браузерах (Chrome, Firefox, Safari) и на мобильных (Chrome Android, Mobile Safari). Использование Flexbox/Grid обеспечит нужную гибкость при минимуме медиазапросов, но при необходимости добавим @media для специфических корректировок.
Анимации и интерактивность интерфейса
Авангардный стиль ассоциируется с динамизмом и смелостью, поэтому уместно добавить слегка нестандартные анимации, оживляющие интерфейс:
•	Hover-эффекты на работах: при наведении на карточку в каталоге – слегка увеличивать изображение (scale(1.05)), показывать оверлей с названием/ценой, или, наоборот, убирать текст чтобы открыть картинку целиком. Это можно делать через CSS transition. Например:
•	.artwork-card .thumb img {
•	  transition: transform 0.3s;
•	}
•	.artwork-card:hover .thumb img {
•	  transform: scale(1.05);
•	}
и затемнение фона можно добавить через :after псевдоэлемент.
•	Перелистывание галереи: плавный fade-in/fade-out или slide при переходе между изображениями. Можно применить библиотеку (swiper.js или Splide) для готовых эффектов или сделать самому с CSS keyframes.
•	Открытие модальных окон (картинки в полный экран, форма входа): добавить анимацию появления (например, с помощью CSS: opacity + translateY).
•	Переключение страниц (транзиции роутера): В SPA, при переходе на другую страницу, по умолчанию контент меняется без спецэффектов. Можно использовать библиотеку Framer Motion <AnimatePresence> или React Transition Group, чтобы сделать плавное перетекание. Например, страница каталога плавно исчезает влево, страница деталей появляется справа. Но аккуратно, чтобы не мешало навигации.
Важно не перегрузить: анимации должны быть короткими (200-500 мс) и не вызывать задержки у пользователя. Также предоставить обратную связь на действия:
•	При добавлении в корзину: можно показать всплывающий toast-уведомление "Добавлено в корзину".
•	При отправке формы заказа: индикатор загрузки и потом сообщение об успехе.
•	При ошибках (например, не удалось загрузить, нет соединения) – уведомления или модалки.
Для реализации анимаций можно применять:
•	Чистый CSS для простых наведения/появления.
•	Framer Motion – мощная библиотека для React, удобна для сложных анимаций, позволяет буквально в JSX прописывать animate={{ opacity: 1 }} initial={{ opacity: 0 }}. Для входа/выхода компонентов Framer Motion очень подходит.
•	GSAP (GreenSock) – heavy-duty анимационная библиотека, наверное излишняя для данного проекта.
•	React Spring – для физически обоснованных анимаций (пружины), но это скорее избыточно.
Для начала, CSS + фреймер хватит.
Обратите внимание на производительность: анимации должны использовать свойства, не вызывающие reflow (трансформации, прозрачность), избегать анимации больших теней или дорогих фильтров. Иначе на слабых устройствах сайт будет "тормозить". Анимации можно отключить (prefers-reduced-motion) для пользователей, которые это указали.
Примеры React-компонентов и UI-решений
Ниже приведём несколько примеров компонентов и решений, используемых в UI:
•	Компонент переключения языка (LanguageSwitcher): отображает текущий язык (например, флаг или сокращение "RU"/"EN") и по клику меняет его. Используя i18next, это может быть так:
•	import { useTranslation } from 'react-i18next';
•	const LanguageSwitcher = () => {
•	  const { i18n } = useTranslation();
•	  const toggleLang = () => {
•	    const newLang = i18n.language === 'ru' ? 'en' : 'ru';
•	    i18n.changeLanguage(newLang);
•	  };
•	  return (
•	    <button onClick={toggleLang}>
•	      {i18n.language === 'ru' ? 'EN' : 'RU'}
•	    </button>
•	  );
•	};
Его можно разместить в навбаре. По возможности, лучше сделать не переключение, а список: выпадающий список языков, если планируются добавления, но для 2 языков и кнопки достаточно.
•	Контекст аутентификации (AuthContext): Создадим React Context, который будет предоставлять информацию о текущем пользователе всем компонентам, которые в ней нуждаются (личный кабинет, приветствие на главной и т.д.). Пример (упрощённо):
•	import { createContext, useEffect, useState } from 'react';
•	import { onAuthStateChanged } from 'firebase/auth';
•	import { auth } from './firebase'; // инициализированный firebase auth
•	
•	export const AuthContext = createContext(null);
•	
•	export const AuthProvider = ({ children }) => {
•	  const [user, setUser] = useState(null);
•	  useEffect(() => {
•	    const unsubscribe = onAuthStateChanged(auth, (firebaseUser) => {
•	      if (firebaseUser) {
•	        // можно тут же запросить доп. данные профиля из нашего API
•	        setUser({ uid: firebaseUser.uid, email: firebaseUser.email });
•	      } else {
•	        setUser(null);
•	      }
•	    });
•	    return unsubscribe;
•	  }, []);
•	  return <AuthContext.Provider value={{ user }}>{children}</AuthContext.Provider>;
•	};
Обернув приложение в <AuthProvider>, внутри компоненты могут сделать:
const { user } = useContext(AuthContext);
if (user) {
  return <p>Привет, {user.email}!</p>
} else {
  return <Link to="/login">Войти</Link>
}
Это используется, например, в навигации (показывать ссылку входа или имя пользователя), а также для защиты маршрутов (если нет user – редирект).
•	Защищённый маршрут (PrivateRoute): с использованием React Router v6 можно написать:
•	// Pseudo-code for route protection:
•	<Route path="/profile" element={
•	  user ? <ProfilePage /> : <Navigate to="/login" replace />
•	} />
Для админ-маршрута:
<Route path="/admin/*" element={
  user && user.role==='admin' ? <AdminApp /> : <Navigate to="/" />
} />
Здесь предполагается, что после логина мы как-то узнаем роль. Можно сразу после onAuthStateChanged вызывать наш API /api/user/me для получения профиля из MongoDB, включая роль, и сохранять это в AuthContext.user.
•	Обработка состояния загрузки и ошибок: Для API вызовов на фронтенде будет использоваться fetch или axios. Стоит реализовать унифицированный подход: создать например api.js с функциями:
•	export async function fetchArtworks(filters) { ... }
•	export async function createOrder(orderData) { ... }
Которые внутри делают fetch, добавляют токен, и возвращают JSON. Эти функции будут использоваться внутри React компонентов с useEffect или по событию onClick. Нужно учесть отображение загрузки (loading spinners) – можно создать небольшой компонент Spinner и состояние loading в компонентах. Например:
const [loading, setLoading] = useState(false);
const [error, setError] = useState(null);
const placeOrder = async () => {
  setLoading(true);
  try {
    await api.createOrder(cart);
    navigate('/order-success');
  } catch (err) {
    setError('Не удалось оформить заказ, попробуйте еще раз');
  } finally {
    setLoading(false);
  }
};
В UI, когда loading true, показываем <Spinner /> вместо кнопки, или дизейблим форму.
•	Соблюдение доступности: Хотя не основное требование, мы постараемся, чтобы интерактивные элементы имели правильные атрибуты (aria-label для иконок кнопок, alt-теги у изображений с описанием работы). Цветовой контраст текста на фоне проверим (WCAG рекомендует контраст не менее 4.5:1 для обычного текста – светло-серый на черном вполне подойдет). Авангардный дизайн не должен идти в ущерб удобству для людей с ограничениями.
Итого, фронтенд реализуется как набор переиспользуемых компонентов (карточки, галерея, модальные окна, формы), объединённых в страницы. Использование современных подходов (хуки, функциональные компоненты, moduler CSS/Styled Components) обеспечит поддерживаемость кода.
Схема базы данных MongoDB
Структура базы данных спроектирована в документно-ориентированном стиле, оптимизированном под запросы, необходимые приложению. Ниже приводится схема основных коллекций и их полей (в формате, близком к Mongoose Schema или JSON-документам):
•	Коллекция users (Пользователи):
o	_id: ObjectId (генерируется автоматически MongoDB).
o	firebaseUid: String – UID пользователя из Firebase Authentication (например, "HJzUgY..."). Индекс по этому полю для быстрого поиска.
o	email: String – Email пользователя (дублируется из Firebase для удобства отображения, консистентность поддерживается либо синхронизацией, либо обновлением через Firebase hooks).
o	name: String – Имя пользователя (может быть заполнено самим пользователем в профиле, необязательно).
o	role: String – Роль пользователя, одно из: "user" (покупатель, по умолчанию) или "admin" (администратор). Можно использовать булево isAdmin, но строка гибче если появятся другие роли.
o	address: String – Адрес доставки по умолчанию (опционально, может быть несколько адресов – тогда можно хранить массив субдокументов, но в нашем случае один основной).
o	phone: String – Телефон (опционально).
o	createdAt: Date – Дата регистрации (ставится при первом сохранении).
o	updatedAt: Date – Дата последнего обновления профиля.
Индексы: помимо firebaseUid, можно добавить уникальный индекс на email (хотя все управление email через Firebase, но для быстрого поиска заказов по email полезно).
Примечание: Пароли не хранятся (в Firebase), поэтому отсутствуют поля hash/salt.
•	Коллекция artworks (Работы):
o	_id: ObjectId.
o	title: Object – объект с локализованными названиями:
	ru: String – название на русском.
	en: String – название на английском.
o	description: Object – описания:
	ru: String – текст описания на русском (можно хранить как markdown или HTML, если нужны форматирования абзацев, либо просто plain text).
	en: String – текст описания на английском.
o	category: String – категория работы (например, "Живопись", "Скульптура"). Здесь можно хранить значение на одном языке (например, на русском) и локализовать в UI, или хранить код категории (like "painting") и иметь словарь, но проще хранить на русском и указать перевод в i18n для англ. версии интерфейса.
o	year: Number – год создания работы (например 2020).
o	size: String – размеры, например "50×70 cm" (можно разделить на ширину/высоту в отдельных полях, если нужны вычисления, но для отображения строкой достаточно).
o	materials: String – материалы или техника (например "холст, масло").
o	price: Number – цена в условных единицах (рублях, либо указать валюту отдельно, но в проекте можно зафиксировать валюту).
o	images: [String] – массив URL-адресов изображений работы. Первый URL – главное изображение (thumbnail/превью), последующие – дополнительные ракурсы. URL могут указывать на Firebase Storage или CDN.
o	available: Boolean – признак наличия. true если работа доступна для продажи, false если уже продана или не в продаже. (Альтернатива – поле status со значениями "available", "sold", "reserved").
o	createdAt: Date – дата добавления в каталог.
o	updatedAt: Date – дата последнего изменения (например, если поправили цену или описание).
Индексы: для быстрого фильтра сделаем составной индекс на поля, участвующие в поиске: { category: 1, price: 1, year: 1 }. Это позволит эффективно выполнять запросы типа "все скульптуры дороже 10000 руб 2018-2020 гг". Также можно добавить текстовый индекс на название и описание, если нужна поисковая строка (фулл-текст поиск в MongoDB).
•	Коллекция orders (Заказы):
o	_id: ObjectId (это номер заказа фактически, можно дополнительно форматировать его как короткий хеш для клиента или просто использовать).
o	userId: ObjectId – ссылка на пользователя, оформившего заказ (ссылается на users._id). Индекс по этому полю, т.к. часто надо запросить все заказы пользователя.
o	items: [Object] – список позиций заказа. Каждый объект:
	artworkId: ObjectId – ссылка на работу (на момент заказа).
	title: String – название работы (скопировано для истории, желательно на том языке, на котором покупатель купил, но можно и два языка сохранить или только один основной).
	price: Number – цена за единицу на момент заказа.
	quantity: Number – количество (для картин обычно 1).
o	totalAmount: Number – общая стоимость заказа (с учётом количества и цены единиц).
o	shippingFee: Number – стоимость доставки (фиксированная, например, 1000 руб).
o	grandTotal: Number – итоговая сумма (totalAmount + shippingFee).
o	shippingAddress: String – адрес доставки, указанный пользователем при заказе. (Лучше сохранить снимок адреса, т.к. он мог отредактировать профиль позже, а заказ должен хранить тот адрес, на который отправляется).
o	createdAt: Date – дата оформления заказа.
o	status: String – состояние заказа, например: "new" (новый, неоплаченный), "paid" (оплачен), "shipped" (отправлен), "completed" (доставлен/завершен), "canceled". Бизнес-логика: при MVP, заказ сразу считается оплаченным (так как оплата заглушка), либо мы отметим в UI "ожидает оплаты". Если интегрируем платежи – новый заказ сначала "pending_payment", затем по webhook станет "paid".
o	paymentInfo: Object – платежная информация, опционально. Например, paymentProvider: "Stripe", paymentId: "ch_xxx", status: "succeeded". Или просто хранить факты в статусе. В MVP можно не заполнять.
o	itemsCount: Number – количество позиций (для удобства).
Индексы: помимо userId, индекс по статусу если надо быстро выбирать новые/оплаченные (например, для админа "все new заказы").
Пример хранения заказа (JSON пример):
{
  "_id": "645f1ab3...",

  "userId": "63cde120...", 
  "items": [
    {
      "artworkId": "614e233...",
      "title": "Композиция №5",
      "price": 20000,
      "quantity": 1
    }
  ],
  "totalAmount": 20000,
  "shippingFee": 1000,
  "grandTotal": 21000,
  "shippingAddress": "Москва, ул. Ленина, д.1, кв.1",
  "createdAt": ISODate("2025-09-17T18:30:00Z"),
  "status": "new",
  "paymentInfo": null
}
Обратите внимание, после оформления заказа логично выставить флаг доступности работы available=false, чтобы она пропала из каталога или отмечалась как проданная (если это оригинал). Эту логику должен обработать сервер: при создании заказа пометить связанные artworks как sold. Нужно быть осторожным, если пользователь успел добавить в корзину уже проданную вещь – при попытке оформить надо отказать.
•	Коллекция categories (опционально): Если нужна, документы вида { _id, code: "painting", name_ru: "Живопись", name_en: "Painting" }. Но можно избежать, т.к. категории нечасто меняются и их немного.
•	Коллекция messages или chats (если бы чат хранился в MongoDB):
Здесь, поскольку мы используем Firestore, в Mongo можно не дублировать. Но теоретически, можно собирать лог чата:
o	_id, userId, sender ("user"/"admin"), text, timestamp.
o	Или документ диалога: { userId, messages: [ {sender, text, timestamp}...] }.
Это на будущее, если хотим иметь историю вне Firebase.
Связи и консистентность: В документных базах нет join-ов как в SQL, но можно вручную подтягивать данные. Например, для отображения заказа админом, нужно показать имя пользователя – наш сервер может запросить user по userId или мы можем продублировать userName в заказе при сохранении. Дублирование упрощает чтение, но усложняет обновление (если юзер сменит имя, в старых заказах останется старое – это не страшно). Можно в заказ сразу поместить и email для удобства. Мы допустим некоторое дублирование (email пользователя, название работы) ради неизменности истории.
Размеры полей и ограничения: Текстовые поля описания могут быть длинными (~несколько тыс символов). MongoDB справится, но если будут храниться большие блобы (не планируется) – лучше выносить. При хранении изображений – мы храним только ссылки, сами файлы вне базы.
Безопасность данных: База MongoDB будет закрыта для прямого доступа извне, взаимодействие только через сервер. Неавторизованные запросы к коллекциям как таковые невозможны. Дополнительно, можно настроить роли на уровне Mongo (но часто не делают для простых веб-приложений). Резервное копирование: если Atlas – включить backups.
Пример схем Mongoose: Для наглядности приведем упрощенную схему Mongoose моделей:
// User model
const UserSchema = new Schema({
  firebaseUid: { type: String, required: true, index: true, unique: true },
  email: { type: String, required: true },
  name: String,
  role: { type: String, default: 'user', enum: ['user','admin'] },
  address: String,
  phone: String
}, { timestamps: true });

// Artwork model
const ArtworkSchema = new Schema({
  title: {
    ru: { type: String, required: true },
    en: { type: String, required: true }
  },
  description: {
    ru: String,
    en: String
  },
  category: String,
  year: Number,
  size: String,
  materials: String,
  price: Number,
  images: [String],
  available: { type: Boolean, default: true }
}, { timestamps: true });
ArtworkSchema.index({ category: 1, price: 1, year: 1 }); // индекс для фильтрации

// Order model
const OrderSchema = new Schema({
  userId: { type: Schema.Types.ObjectId, ref: 'User', index: true },
  items: [{
    artworkId: Schema.Types.ObjectId,
    title: String,
    price: Number,
    quantity: Number
  }],
  totalAmount: Number,
  shippingFee: Number,
  grandTotal: Number,
  shippingAddress: String,
  status: { type: String, default: 'new', enum: ['new','paid','shipped','completed','canceled'] },
  paymentInfo: Schema.Types.Mixed
}, { timestamps: true });
Эта структура будет гибкой для расширения – например, можно добавить коллекцию reviews для отзывов на работы, или events (выставки) без затрагивания существующих.
Интеграция с Firebase (Auth и Realtime Chat)
Как ранее описано, система опирается на Firebase для решения двух задач: аутентификация пользователей и реализация чата (реального времени обмена сообщениями). В этом разделе подробно рассмотрим шаги интеграции и взаимодействие с Firebase.
Авторизация пользователей через Firebase Auth
Использование Firebase Authentication предоставляет готовый бэкенд для регистрации и входа пользователей и упрощает хранение паролей (нам не нужно самостоятельно их хранить, Firebase делает это безопасно). Чтобы интегрировать Firebase Auth в веб-приложение и собственный сервер, нужно выполнить следующие настройки:
1.	Настройка проекта Firebase: Создается проект на Firebase Console. В разделе Authentication включаются нужные методы входа – для MVP включаем Email/Password. Получаем настройки для веб-приложения (apiKey, authDomain, проектный ID и т.д.). Эти параметры понадобятся на фронтенде для инициализации.
2.	Инициализация Firebase на фронтенде: В коде React устанавливаем пакет firebase (npm install firebase) и создаем модуль конфигурации:
3.	// firebase.js
4.	import { initializeApp } from "firebase/app";
5.	import { getAuth } from "firebase/auth";
6.	import { getFirestore } from "firebase/firestore";
7.	
8.	const firebaseConfig = {
9.	  apiKey: "XYZ...",
10.	  authDomain: "your-project.firebaseapp.com",
11.	  projectId: "your-project-id",
12.	  storageBucket: "your-project.appspot.com",
13.	  appId: "1:123456:web:abcdef"
14.	  // ... остальные поля
15.	};
16.	const app = initializeApp(firebaseConfig);
17.	export const auth = getAuth(app);
18.	export const db = getFirestore(app);
Здесь мы сразу и Firestore инициализируем (db), поскольку будем использовать его для чата.
19.	Регистрация нового пользователя: Когда пользователь заполняет форму регистрации и отправляет, вызываем createUserWithEmailAndPassword(auth, email, password). Этот Promise возвращает объект пользователя (userCredential). В момент регистрации можно также сразу обновить профиль (displayName, photoURL) если нужно. Firebase автоматически сохраняет сессию (устанавливает cookie/внутренний токен).
o	После успешной регистрации нужно создать соответствующую запись в нашей базе MongoDB (профиль). Для этого фронтенд может сделать запрос на наш сервер: POST /api/user/register с необходимыми данными (например, имя, адрес – если собираем) и в заголовке тот же Firebase ID токен, чтобы сервер убедился, что запрос аутентифицирован. Сервер, получив запрос, выполнит verifyIdToken, узнает uid и создаст документ в users с firebaseUid = uid, заполнит поля (email, name и т.п.)tempmail.us.com. Альтернативный способ – слушать webhook Firebase или использовать Cloud Function onCreate User, но это сложнее и выходит за рамки.
o	Если не хотим лишнего запроса, можно отложить создание профиля до первого обращения (лениво). Однако, лучше создать сразу, чтобы можно было хранить доп. данные.
20.	Вход пользователя: При логине вызывается signInWithEmailAndPassword(auth, email, password) или соответствующий метод для соцсетей (например, signInWithPopup(auth, googleProvider)). После входа Firebase хранит в приложении текущего пользователя и выдает ID токен. Его можно получить вызовом auth.currentUser.getIdToken() – он нужен для серверных запросов.
o	Все дальнейшие действия в приложении, требующие авторизации (например, добавление в корзину можно делать без сервера, а вот оформление заказа – на сервер) – будут прикреплять этот токен. Можно использовать onAuthStateChanged или auth.currentUser в момент запроса.
o	Настраиваем глобально: например, в Axios можно установить интерцептор, который перед каждым запросом к нашему API добавляет заголовок:
o	axios.interceptors.request.use(async (config) => {
o	  const token = await auth.currentUser?.getIdToken();
o	  if (token) {
o	    config.headers.Authorization = `Bearer ${token}`;
o	  }
o	  return config;
o	});
Если fetch – придётся каждый раз явно добавлять:
const token = await auth.currentUser.getIdToken();
fetch('/api/orders', { 
  method: 'POST',
  headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
  body: JSON.stringify(orderData)
});
o	Важно: ID токен истекает через 1 час. Firebase SDK автоматически обновляет его в фоне, но если мы храним его где-то отдельно, надо учесть этот момент. Лучше каждый раз запрашивать свежий через getIdToken() (как выше).
o	На сервере, как описано, есть middleware для проверки:
o	const admin = require('firebase-admin');
o	admin.initializeApp({ credential: admin.credential.cert(serviceAccount) });
o	//...
o	async function authMiddleware(req, res, next) {
o	  const authHeader = req.headers.authorization;
o	  if (!authHeader) return res.status(401).send('No token');
o	  const token = authHeader.split(' ')[1];
o	  try {
o	    const decoded = await admin.auth().verifyIdToken(token);
o	    req.user = decoded; // в decoded будет uid и, возможно, доп. инфо
o	    next();
o	  } catch(err) {
o	    res.status(401).send('Invalid token');
o	  }
o	}
Это основано на Firebase Admin SDK, который инициализирован с нашим сервисным аккаунтом. Этот аккаунт имеет право проверять токены. В объекте decoded токена могут быть и кастомные claim-ы, например admin: true если мы зададим.
o	Этот middleware применяем ко всем защищённым маршрутам, например:
o	app.post('/api/orders', authMiddleware, createOrderHandler);
o	app.get('/api/admin/orders', authMiddleware, adminOnly, listOrdersHandler);
Где adminOnly – ещё один middleware, который после authMiddleware проверяет req.user.uid в базе или claim. Можно оптимизировать: добавить custom claim "admin" в Firebase Auth пользователю администратору – тогда decoded.admin будет true. Если мы так сделаем, проверка упрощается:
function adminOnly(req, res, next) {
  if (req.user.admin) next();
  else res.status(403).send('Forbidden');
}
Custom claim можно задать через Admin SDK, однократно:
admin.auth().setCustomUserClaims(adminUid, { admin: true });
После этого при каждом verifyIdToken это поле будет.
o	Регулярная синхронизация: Если пользователь меняет email через Firebase (мы не реализуем возможно), но если – стоит обновить и Mongo, чтобы email в профиле был актуальным. Это можно сделать в момент изменения (Firebase Auth не триггерит автоматически внешний код, разве что Cloud Function), или при каждом входе.
o	Выход: auth.signOut() – на клиенте, это уничтожает сессию, UI перестраивается, токен становится невалидным. Пользовательские куки/данные стоит очистить (корзину, если хранилась для авторизованного).
Итог: система авторизации построена на Firebase обеспечивает единый источник истинности пользователей, а наша база MongoDB хранит расширенные сведения. Связка выполняется через UID. Такой подход проверен на практике – Firebase Auth может использоваться независимо от Firebase DB легкоtempmail.us.com. Он сокращает время разработки и повышает безопасность (Google берет на себя хранение паролей, 2FA, и т.п.). Наш сервер просто проверяет токены и реагирует.
Реализация чата на Firebase Firestore
Для функции поддержки клиентов реализован чат "пользователь – администратор". Основные требования: сообщения должны доставляться мгновенно, храниться для истории, и быть видны только отправителю и администратору. Firebase Firestore отлично подходит под эти требования, предоставляя out-of-the-box realtime sync и управление доступом.
Структура данных в Firestore:
•	Коллекция chats – в ней документы чатов. Каждому пользователю при обращении в чат соответствует один документ или подколлекция. Есть два подхода:
1.	Подколлекции сообщений: Например, создать документ чата с id = UID пользователя, а внутри него подколлекцию messages. Документ чата может содержать метаданные (например, последний месседж, время, флаг прочитано админом). Все сообщения хранятся как отдельные документы в chats/{uid}/messages/{msgId}. Поля сообщения: text, sender, timestamp. Firestore поддерживает субколлекции, и это удобно разделяет по пользователям.
2.	Единая коллекция сообщений: Все сообщения лежат в одной коллекции messages с полями: userId, sender, text, timestamp. Чтоб получить чат конкретного пользователя, делаем запрос по фильтру userId. Однако, Firestore позволяет поставить правила безопасности: например, request.auth.uid == resource.data.userId для чтения. Этот вариант тоже возможен. Минус – тяжелее получать "только сообщения этого пользователя" (нужен композитный индекс userId+timestamp). Но плюс – проще для админа вытащить все новые сообщения (в первом подходе админу надо по всем subcollections ходить).
Для простоты разработки, выберем первый подход (каждый чат – отдельная подколлекция). Это логично, так как один пользователь = одна цепочка диалога.
Пример:
chats (collection)
 └── ${userUid} (document)
      ├── createdAt: ... (можно хранить, когда начат чат)
      ├── userEmail: ... (для удобства админа)
      └── messages (subcollection)
            ├── ${msgId1} (document)
            │    ├─ text: "Здравствуйте! Подскажите, ...?"
            │    ├─ sender: "user"
            │    └─ timestamp: March 1, 2025 12:00:00
            ├── ${msgId2} (document)
                 ├─ text: "Добрый день! Спасибо за интерес ... (ответ администратора)"
                 ├─ sender: "admin"
                 └─ timestamp: March 1, 2025 12:05:00
Настройка безопасности (Firestore Security Rules):
В Firebase Console задаются правила, чтобы:
•	Обычный аутентифицированный пользователь мог читать и писать только в свой документ чата и вложенные сообщения.
•	Администратор мог читать/писать во все (можно вообще для simplicity сказать, что админ будет использовать привилегии сервиса – но он у нас тоже аутентифицирован как юзер с claim).
•	Неавторизованные – никуда.
Пример правил:
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /chats/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      match /messages/{messageId} {
        allow read, create: if request.auth != null && request.auth.uid == userId;
      }
    }
    // Additionally, allow admin to access any chat
    match /chats/{userId} {
      allow read, write: if request.auth.token.admin == true;
      match /messages/{messageId} {
        allow read, create: if request.auth.token.admin == true;
      }
    }
  }
}
Здесь request.auth.token.admin будет работать если мы установили custom claim "admin" (или вместо этого можно отдельную коллекцию roles, но custom claim проще).
На практике, можно упростить: добавить правило, что если email совпадает с админским email. Но лучше claims.
Фронтенд реализация:
•	Когда пользователь открывает чат (например, кликом на "Написать вопрос"), мы монтируем компонент ChatWindow. Этот компонент при монтировании запускает подписку:
•	import { collection, query, orderBy, onSnapshot } from 'firebase/firestore';
•	...
•	useEffect(() => {
•	  if (!currentUser) return;
•	  const q = query(collection(db, 'chats', currentUser.uid, 'messages'), orderBy('timestamp'));
•	  const unsubscribe = onSnapshot(q, (snapshot) => {
•	    const msgs = snapshot.docs.map(doc => doc.data());
•	    setMessages(msgs);
•	  });
•	  return unsubscribe;
•	}, [currentUser]);
Это будет слушать все новые сообщения в чате данного пользователя. Так как правила позволяют ему только свой чат, все ок.
•	Для отправки сообщения:
•	import { addDoc, serverTimestamp } from 'firebase/firestore';
•	...
•	const sendMessage = async () => {
•	  if (!newMessageText.trim()) return;
•	  await addDoc(collection(db, 'chats', currentUser.uid, 'messages'), {
•	    text: newMessageText,
•	    sender: 'user',
•	    timestamp: serverTimestamp()
•	  });
•	  setNewMessageText('');
•	};
Firestore проставит серверное время. Клиент тоже видит сразу (optimistic UI).
•	Администраторский фронтенд: очень похож, только у админа надо подписаться на все чаты или на выбранный. Подход: админ открывает список чатов – нужно получить список документов chats (без сообщений, может с последним). Каждый документ chats/{uid} можно хранить lastMsg: "текст...", lastTime: timestamp, unreadCount. Мы можем обновлять эти поля с каждой записью (через Cloud Function onWrite, или просто на клиенте писать дубли). Это возможно, но для MVP не критично. Админ может отобразить список чатов, допустим отсортированный по времени последнего сообщения: для этого либо делать запрос на все messages (неэффективно), либо поддерживать lastTime поле.
Возможно, проще: уведомлять админа о новых сообщениях – Firebase Cloud Messaging, но это сложно. В админ-панели можно сделать принудительное отображение: напр., периодически проверять (poll) либо заставить админа открыть конкретный чат.
Лучше реализовать, что список чатов появляется когда пользователь сам напишет. Админ может увидеть, у кого есть сообщения:
o	В rules мы разрешили админ читать все, значит он может сделать onSnapshot на всю коллекцию chats и вложенные. Но Firestore не позволяет слушать подколлекции всех документов без какого-то trюка (только либо конкретно, либо через расширенный queries).
o	Можно поступить иначе: админ панель будет иметь выпадающий список пользователей, начнет чат с выбранным, и тогда подпишется на его messages.
Учитывая, что клиентов не тысячи, можно получить список всех users из MongoDB и показать. Или даже хранить коллекцию chats где каждый документ содержит, скажем, поле userId (дубль id) + lastMsg. Админ подпишется на collection(db, 'chats') - получит добавление документов когда новый пользователь написал.
o	Firestore subcollection queries (collectionGroup) могли бы помочь (например, listen to all messages collection group), но нужно осторожно, чтобы не вытащить миллионы. Admin, теоретически, может использовать:
o	const q = query(collectionGroup(db, 'messages'), where('sender', '==', 'user', ...somehow unread?), orderBy('timestamp', 'desc'));
И отслеживать. Но это слишком.
Упростим: на MVP админ будет знать, что кто-то написал, только открыв консоль или получив другое уведомление. На этапе 2 – сделаем отдельный UI.
Серверная интеграция чата: Прямого участия сервера нет, клиент общается с Firebase напрямую (кроме правил). Можно, однако, интегрировать:
•	Логирование: Cloud Firestore Trigger (с помощью Cloud Functions) на создание документа, например, писать копию в MongoDB (необязательно).
•	Отправка email администратору, когда новый чат сообщение пришло: тоже Cloud Function. Это advanced.
•	Потенциально, можно было реализовать чат через наш сервер (сокеты). Но Firestore удобнее для быстрого старта.
Ограничение и тарифы: Firestore – платный после определенных объемов. Но текстовые сообщения – очень маленькие, сотни или тысячи сообщений не проблема. Правила безопасности предотвратят несанкционированный доступ, но можно также ограничить длину сообщения на клиенте (например, 500 символов).
UX чата:
•	Пользовательский виджет: можно сделать плавающую кнопку чата ("Помощь") на всех страницах, открывающую окно. Либо интегрировать в страницу контактов или детальной работы.
•	Админ: получив возможность отвечать прямо в панели, сможет вести диалоги параллельно.
Каталогизация, корзина и оформление заказа
Этот раздел описывает, как реализованы функции e-commerce на сайте: фильтрация каталога, добавление в корзину, процесс оформления заказа и чек-аут (до интеграции платежей и после).
Каталог работ и фильтры
Получение данных каталога: При загрузке страницы "Каталог" фронтенд отправляет запрос к API сервера для получения списка работ. Например: GET /api/artworks. Сервер обращается к коллекции artworks в MongoDB и возвращает массив документов (можно преобразовать в более легкий вид, убрав лишнее или форматы дат). Если работ очень много, нужно добавить пагинацию – например, API принимает ?skip=0&limit=20 или ?page=2&pageSize=20. В MVP, вероятно, работ десятки, пагинацию можно не делать, а реализовать позже бесконечную прокрутку.
Реализация фильтрации на сервере:
•	API можно спроектировать так: клиент передает параметры фильтров, сервер строит запрос MongoDB.
Например, фильтр категорий: category=Painting (одну категорию), или category=Painting,Drawing (несколько, тогда $in оператор).
Фильтр цены: передавать priceMin=1000&priceMax=5000. Сервер сделает { price: { $gte: 1000, $lte: 5000 } }.
Год: yearFrom=2010&yearTo=2020 -> { year: { $gte: 2010, $lte: 2020 } }.
Размер: сложнее, если хранится строкой. Можно завести условные размеры (Small/Medium/Large) и передавать их. Либо игнорировать размер как числовой фильтр на первом этапе.
•	Пример GET-запроса: /api/artworks?category=Живопись&maxPrice=100000&yearFrom=2015.
•	Сервер декодирует параметры, формирует объект фильтра и делает Artworks.find(filterCriteria) с использованием Mongoose. Затем сортирует, например, по году убыванию или так как удобно (можно добавить параметр sort).
•	Результат – JSON с массивом. Нужно помнить отправлять нужный язык текста: либо оба (и на клиенте выбирать), либо, чтобы снизить размер, только один. Например, если клиент указал Accept-Language: ru (или мы знаем из состояния, что сейчас ru), можно вернуть только ru-поля. Но лучше вернуть все, потому что клиент может мгновенно переключить язык. Для MVP – можно вернуть все, это чуть лишние байты, но не критично.
Применение фильтров на клиенте:
•	Изначально показываются все работы (или отфильтрованные, если есть дефолтный фильтр).
•	Когда пользователь меняет условия фильтра, сразу делаем новый запрос или ждем сабмита.
•	Сопровождаем индикатором загрузки (может, спиннер на месте списка).
•	Обновляем artworks состояние – React ре-рендерит карточки.
•	Если ничего не найдено, показываем "По вашему запросу ничего не найдено".
•	Разработаем также сброс фильтров.
UX:
•	Желательно, чтобы выбранные фильтры можно было убирать (например, выбранные категории – кнопкой "×").
•	Можно отобразить количество найденных работ.
•	Фильтр по цене – можно использовать диапазонный input (type="range" в двойном варианте нет стандартного, но можно использовать библиотеки или два ползунка).
•	Фильтр по году – для удобства, может быть список десятилетий, либо слайдер как по цене.
•	Если категорий < 10, можно чекбоксы; если больше – мультиселект.
Пример запроса в MongoDB (Mongoose) для фильтра:
const criteria = {};
if (query.category) {
  const categories = query.category.split(',');
  criteria.category = { $in: categories };
}
if (query.priceMin || query.priceMax) {
  criteria.price = {};
  if (query.priceMin) criteria.price.$gte = Number(query.priceMin);
  if (query.priceMax) criteria.price.$lte = Number(query.priceMax);
}
if (query.yearFrom || query.yearTo) {
  criteria.year = {};
  if (query.yearFrom) criteria.year.$gte = Number(query.yearFrom);
  if (query.yearTo) criteria.year.$lte = Number(query.yearTo);
}
const artworks = await Artwork.find(criteria).sort({ year: -1 }).lean();
res.json(artworks);
С индексами это будет работать быстро даже на тысячах документовtempmail.us.com. На фронтенде нужно лишь сформировать правильный URL.
Корзина (Cart)
Корзина выступает промежуточным хранилищем выбранных к покупке работ. Поскольку характер товаров – уникальные работы, ситуация "много штук одного товара" скорее не актуальна. Корзина, по сути, список id работ, которые пользователь желает приобрести. Реализовать корзину можно двумя путями:
•	На клиенте (локально): хранить в React состоянии (или через Context), а при перезагрузке – в localStorage. Это проще, но корзина будет привязана к устройству. Если пользователь залогинен и перейдет на другой девайс – корзина там пустая. Возможно, это не критично, но для полноценности лучше синхронизировать.
•	На сервере (в базе): хранить корзину в MongoDB, привязанную к пользователю. Можно добавить поле cart в документ users (массив артов) или отдельную коллекцию carts (где ключ – userId, value – items). При каждом добавлении в корзину, фронтенд шлет запрос, а сервер обновляет. Это дает persistency между устройствами. Однако, увеличивает количество запросов и сложность (надо получать корзину при логине, и т.д.).
Для MVP, учитывая что каталог – не супермаркет, а скорее галерея, мы можем начать с клиентской корзины:
•	Пользователь нажимает "Добавить в корзину" на странице работы. Если он не авторизован, можно сразу направить на регистрацию/вход или позволить добавить без входа. Но для оформления все равно потребуется аккаунт (в требованиях не сказано о гостевом оформлении, лучше требовать логин чтобы чат, профиль и прочее).
Поэтому вариант: при добавлении без входа – показать popup "Для добавления в корзину нужно войти" или автоматически перенаправить на login.
Второй вариант: позволить гостю набрать корзину, а на шаге оформления – попросить логин.
В UX магазинов часто второе. Тогда корзина хранится временно в localStorage у гостя, а после логина можно спросить "добавить ваши сохраненные товары в корзину аккаунта?" – можно, но можно и просто продолжить.
•	Допустим мы храним корзину как массив объектов { artworkId, title, price } (тоже можно цену зафиксировать вдруг она изменится пока он думает). В React сделаем Context CartContext, с методами addItem, removeItem, clearCart.
•	Компонент корзины (CartPage) выводит список выбранных работ, суммирует цену (сразу можно рассчитать total). Пользователь может удалить из корзины (например, передумал). Если когда-то планируется позволять несколько картин добавить, этот функционал нужен. Если всегда одна – корзина почти избыточна. Но мы делаем много, может пользователь несколько купит.
•	Если работа уже продана, стоит при добавлении проверять. Можно, при открытии страницы работы, если available=false, вместо "в корзину" показывать "Продано".
•	Особый случай: два пользователя одновременно пытаются купить одну работу. Первый оформил, второй пока держит в корзине. Если второй попытается оформить позже, сервер при создании заказа проверит available и откажет. Можно предусмотреть: при добавлении в корзину отмечать работу как "резерв" на какое-то время. Но для MVP не будем, слишком сложно.
Страница корзины: Показывает таблицу: Название работы, цена, может количество (по умолчанию 1, можно не отображать если нет смысла менять), и итого. Внизу: "Стоимость работ: X руб", "Доставка: Y руб (фиксировано)", "Итого: X+Y руб". Кнопка "Оформить заказ". Если пользователь не вошел – здесь точно надо форсировать вход: кнопку либо дизейблить с требованием войти, либо по нажатию открыть модал логина.
Оформление заказа и чек-аут
Форма оформления заказа:
•	Если пользователь уже залогинен и у него заполнен профиль (адрес, телефон), можно сразу перейти к подтверждению.
•	Если нет – показываем форму "Введите адрес доставки и контактный телефон". Эти данные можно сохранить в профиль (по чекбоксу "сохранить в моем профиле для будущих покупок").
•	В простейшем случае, можно вообще не делать отдельный шаг, а при нажатии "Оформить" взять адрес из профиля. Но лучше дать возможность изменить/ввести. Сделаем модальное окно или отдельную страницу "Checkout".
•	Этапы checkout: (1) Адрес, контакты -> (2) Оплата.
•	Поскольку оплаты пока нет, эти два сливаются.
•	После подтверждения формы, фронтенд отправляет POST /api/orders с данными: { items: [id,id,...], shippingAddress: "...", ... }.
o	На сервере middleware auth проверит пользователя. Затем create order: проверяет items по базе – загружает соответствующие работы:
o	const arts = await Artwork.find({ _id: { $in: itemsIds } });
o	// проверить, что количество совпадает (не больше 1 уникальных, уникальность можно на клиенте и так), 
o	// и что все available.
o	const notAvailable = arts.filter(a => !a.available);
o	if (notAvailable.length) {
o	  return res.status(400).json({ error: "Some items are not available", items: notAvailable.map(x=>x._id) });
o	}
Если все ок, формирует ордер:
const order = new Order({
  userId: req.userDoc._id,  // req.userDoc предположим мы получили профайл до этого
  items: arts.map(a => ({
    artworkId: a._id,
    title: a.title[preferredLang] || a.title.ru, // можно сохранить в одном языке (русском, например)
    price: a.price,
    quantity: 1
  })),
  totalAmount: arts.reduce((sum,a)=> sum + a.price, 0),
  shippingFee: FIXED_SHIPPING_FEE,
  grandTotal: total + FIXED_SHIPPING_FEE,
  shippingAddress: req.body.shippingAddress,
  status: "new"
});
await order.save();
// И обновить работы:
await Artwork.updateMany({ _id: { $in: itemsIds } }, { $set: { available: false } });
Статус "new" говорит, что заказ создан, но не оплачен (если мы решим только после оплаты менять). Если пока оплаты нет, можем сразу пометить "paid".
Вернуть ответ фронтенду: order id или полный объект, или сообщение успеха.
o	Сервер может также отправить email уведомления (опционально).
o	Если произошла ошибка (например, работа недоступна) – вернуть ошибку, фронтенд покажет пользователю.
•	После успешного оформления:
o	Очищаем корзину (контекст, localStorage).
o	Показываем пользователю страницу "Спасибо за заказ!" (Order Confirmation) с номером заказа и деталями. Можно предложить распечатать или перейти в кабинет для отслеживания.
o	Если предполагается offline оплата (например, перевод или наложенный платеж), эту инфу тоже здесь указать.
•	Интеграция оплаты (будущий этап):
o	Когда подключим платежную систему, то процесс видоизменится:
	Нажатие "Оформить заказ" будет сначала создавать Payment Session. Например, для Stripe – фронтенд или сервер вызовет Stripe API, передав сумму и описание. Stripe вернет ссылку (или require redirect).
	Пользователя переадресует на страницу оплаты (хостится на стороне Stripe, безопасно).
	После оплаты, Stripe сделает webhook на наш сервер (отдельный маршрут) с инфо о платеже. Мы найдем соответствующий order (нужно orderID передавать как metadata, либо создавать order сначала "pending").
	Обновим статус order на "paid", и, возможно, отправим email подтверждение.
	Фронтенд, после оплаты, по возвращению (Stripe может перенаправить на success_url), должен отобразить успех.
	Это сложнее, но выполнимо. Есть альтернатива – использовать просто номер карты на сайте (но тогда надо соблюдать PCI DSS, не нужно).
o	Пока же, в MVP: возможно, продавать работы можно и без онлайн-оплаты – админ свяжется и договорится об оплате/доставке. Поэтому даже без интеграции сайт полезен.
•	Фиксированная доставка: Значение фикс.стоимости (скажем, 1000 руб) зашиваем в конфиг сервера. На странице оформления отображаем пользователю явно. Если планируются разные регионы – можно сделать простой выбор "Доставка по РФ 1000 руб, СНГ 2000 руб, Международная 5000 руб" – но в ТЗ прямо указано фикс, так что не будем усложнять.
•	Обработка заказов администратором: После заказа админ увидит новый заказ в панели. По мере выполнения, админ меняет статус. При смене статуса можно уведомлять пользователя: либо по email (например, письмо "Ваш заказ отправлен"), либо если пользователь заходит в кабинет – видит обновление. Real-time обновление статуса можно сделать через тот же Firestore (но тут лучше уже не надо, можно poll).
•	Отмена заказа: Если у нас без онлайн-оплаты, пользователь может передумать. Можно позволить ему отменить заказ из кабинета, пока админ не отгрузил. Тогда вернуть работы в available. Это edge case, можно добавить, но не обязано.
Все данные процесса оформления и итоги (чек) фиксируются, пользователь может потом еще раз посмотреть заказ (в личном кабинете) – это и будет своего рода чек (можно сгенерировать PDF, но лишнее).
Административная панель
Админ-панель – ключевой инструмент для художника, позволяющий управлять контентом сайта и взаимодействовать с покупателями. Ниже описана ее функциональность более структурировано:
Доступ и безопастность:
•	Вход в админ-панель осуществляется через ту же страницу логина, используя учетные данные администратора. Как было описано, механизм разграничения прав основан на проверке роли (в MongoDB или Firebase claims). Дополнительно, можно предусмотреть 2FA (через Firebase Multi-factor Auth) для админа, учитывая важность безопасности, но это опционально.
•	Админ-панель должна быть недоступна публично: прямой маршрут /admin защищен; возможно, стоит убрать ее из публичного меню (например, отображать пункт "Админ-панель" только если user.isAdmin). Таким образом, случайный пользователь не узнает о существовании этого раздела.
Основные разделы админ-панели:
1.	Дашборд (Обзор): Стартовая страница админки. Здесь могут отображаться краткие сведения:
o	Количество опубликованных работ в каталоге.
o	Количество проданных (или проданных за месяц).
o	Число открытых заказов (в статусе "new"/"paid" ожидающих отправки).
o	Возможно, индикатор новых непрочитанных сообщений от пользователей.
o	Эти показатели можно оформить крупными цифрами или небольшими карточками.
o	Дашборд носит информативный характер и помогает быстро оценить активность.
2.	Каталог работ (управление работами): Страница со списком всех работ, как видит администратор:
o	Список можно отобразить таблицей: колонки "Название (RU)", "Название (EN)", "Категория", "Цена", "Статус" (наличие/продано), "Действия".
o	Или сеткой карточек с миниатюрами, т.к. визуально может быть удобнее. Но для редактирования/сортировки таблица точнее.
o	Поиск/фильтр для админа: админ может искать работу по названию (например, вводит часть названия, фильтруется список). Можно использовать простой Array.filter или запрос к API /api/admin/artworks?search=....
o	Добавление работы: Кнопка "Добавить новую работу" открывает форму создания:
	Поля: Название (RU/EN), Описание (RU/EN) – можно сделать textarea, а если нужно форматирование текста (курсив, абзацы), можно подключить простой Markdown-редактор или оставлять простой текст.
	Год (input type="number"), Размер (строка или 2 поля шир/выс).
	Категория – выпадающий список существующих категорий + опция ввести новую. Если новая введена, сервер может либо добавить в список, либо просто сохранить строку.
	Цена (number).
	Изображения – элемент для загрузки файлов. Лучше позволить мультивыбор нескольких файлов сразу. После выбора файлов, можно показать превью и возможность удалить/заменить до загрузки.
	При сабмите: фронтенд собирает данные. Изображения надо загрузить:
	Либо один подход: сначала послать POST /api/admin/artworks без изображений, получить созданный ID, затем по ID загружать изображения (не очень удобно, 2 шага).
	Лучше: использовать Firebase Storage SDK на клиенте:
	Получить ссылки: Firebase Storage require auth, но можно сделать правилом, что только админ (по uid) может писать в bucket.
	Для каждого файла выполнить uploadBytes или uploadString (если base64). После завершения – получить getDownloadURL().
	Собрать массив downloadURLs, включить их в payload и вызывать POST /api/admin/artworks с остальными полями плюс images: [url1, url2...].
	Этот путь избавляет от написания загрузки файлов на сервере.
	Сервер, приняв запрос, проверит токен админа, создает документ в MongoDB.
	Опционально, сервер мог бы сам общаться с Cloud Storage (Google Storage) через Admin SDK, но от клиента проще.
	После создания: новая работа появляется в общем списке, а на пользовательском сайте – в каталоге (если мы не делаем модерацию).
	Возможные улучшения: в форме можно валидировать поля (пустое название – нельзя, цена >=0, год <= текущего).
o	Редактирование работы: В списке у каждой работы кнопка "Редактировать". При нажатии – та же форма, но заполнена текущими данными. Можно реализовать как отдельная страница /admin/artworks/:id/edit или модальное окно. При сохранении – фронтенд отправляет PUT /api/admin/artworks/:id с изменениями. Сервер применяет Artwork.findByIdAndUpdate.
	Если поменялись изображения: сложнее, надо уметь удалять старые из Storage. В MVP можно не реализовать удаление файлов (просто пусть висят, не страшно). Если админ хочет заменить изображения, можно загрузить новые URL и отправить весь новый массив.
	Также, если изменилось поле available (например, админ может вручную пометить продано, если картина продалась оффлайн) – надо учесть.
o	Удаление работы: Кнопка "Удалить". Требует подтверждения ("Вы уверены?"). При подтверждении – DELETE /api/admin/artworks/:id. Сервер удалит документ из MongoDB.
	Важно: что делать с изображениями? Можно тоже удалить из Storage (Firebase Storage имеет метод delete by URL if we convert to ref). Либо оставить, если не критично (они занимают место, но может пригодится). Правильно – удалять.
	Если работа была в заказах, при удалении можно либо запретить удаление (лучше не удалять, если продано), либо помечать "удалена". Для MVP, предположим, можно удалить только работы, которые не проданы (и админ будет это понимать).
	А если удалил, а она была в заказе, в заказе останется просто текст, ничего страшного.
3.	Управление заказами: Интерфейс, помогающий администратору отслеживать и изменять состояние заказов:
o	Список заказов (таблица): колонки "№ заказа", "Дата", "Покупатель", "Сумма", "Статус", "Действия". Можно сортировать по дате, фильтровать по статусу (например, показать только "новые" заказы – очень полезно).
o	При нажатии на конкретный заказ или кнопку "Просмотр" – открываются детали:
	Состав заказа: перечень работ (название, цена, количество).
	Контактная информация: имя покупателя, email, телефон, адрес доставки.
	Статус: выпадающий список или радиокнопки для изменения. Например, админ получил оплату – ставит "paid"; отправил – "shipped".
	Поле для ввода доп. информации: например, трекинг-номер посылки. Можно расширить схему заказа, добавив trackingNumber, deliveryService и поле notes.
	Кнопка "Сохранить/Обновить" статус.
o	Когда админ меняет статус, сервер обновляет документ заказа. Можно также триггерить уведомление пользователю (например, если статус стал "shipped", отправить письмо с трек-номером).
o	Если статус "canceled" – можно вернуть работу на сайт (сделать ее available снова). Это тоже должно делаться сервером: при cancel он может найти items и вернуть их флаг available: true если еще не проданы в другом.
o	Заказы лучше не позволять удалять, даже после завершения (для учета). Можно сделать кнопку "Удалить", но тогда потеряется история – не нужно.
4.	Чат (сообщения пользователей):
o	Как обсуждали, интерфейс чата для админа – список диалогов + текущее окно переписки:
	Список диалогов: можно показывать все, у кого есть документ в chats. Как получить этот список? При загрузке этого раздела, можно через Firebase JS SDK получить все документы chats (Firestore) - но по безопасности админ может, по claim.
getDocs(collection(db, 'chats')) вернет все документы (ids, и там fields как createdAt).
У нас chat document fields может содержать userEmail или userName для удобства. Если мы заранее не сохраняли, можно на лету мапить UID->имя через Mongo.
Например, взять все docs -> получить их IDs -> запросить MongoDB пользователей, чьи firebaseUid in [IDs] -> сматчить email/имя.
	После этого, показать список: например "Пользователь user@example.com, последнее сообщение 10.09.2025".
	При выборе диалога, аналогично подписаться на onSnapshot(collection(db, 'chats', selectedUid, 'messages'), orderBy('timestamp')) и вывести.
	Отправка сообщения:
	addDoc(collection(db, 'chats', selectedUid, 'messages'), {
	  text: adminMessage,
	  sender: 'admin',
	  timestamp: serverTimestamp()
	});
	Поскольку у админа может быть много диалогов, можно оптимизировать: получать сообщения выбранного чата только когда он открыт, а не все сразу. Это в порядке.
	UI: можно использовать готовые стили или компоненты для чата (bubble left/right).
	Опционально: помечать сообщения как прочитанные. Например, когда админ открыл чат, можно пробежаться и выставить поле read = true на все сообщения sender=user. Или иметь отдельное поле lastReadByAdmin: timestamp в документе чата, и highlight непрочитанные. Это для этапа 2 или 3, если нужно.
5.	Прочие секции:
o	Управление страницами ("О художнике", "Контакты"): Если предусмотрено редактирование контента, то админ-панель может иметь форму редактирования этих текстов. Например, текст "О художнике (RU/EN)" хранится в MongoDB коллекции pages или settings.
Админ меняет, сохраняет -> сайт берет оттуда (или можно просто держать их в i18n JSON и обновлять вручную, но раз хочется ТЗ).
o	Управление категориями: Если категории арт-работ часто меняются, можно иметь раздел, где они перечислены, и админ может добавить/удалить категорию. Но можно обойтись без этого, позволяя при добавлении работы вводить новую категорию (как упоминалось).
o	Пользователи: В принципе, админ может просматривать список зарегистрированных пользователей. Не обязательная функция, но полезно: видеть всех клиентов, возможно, банить кого-то (вряд ли нужно банить в таком сайте), присваивать вторую роль (например, модератор если будет). Можно вывести просто таблицу user (email, name, registered date, count of orders).
o	Аналитика: В далекой перспективе, можно графики продаж по месяцам, популярность категории – но это вне текущих требований.
Технологии в админке:
•	Можно применять готовые UI-фреймворки для ускорения: Ant Design (antd) или Material-UI (MUI). Они дают сразу красивые таблицы, формы с валидацией, пикеры дат. Например, форма добавления работы – в AntD это <Form> c <Form.Item> и <Input>.
•	Это немного утяжелит бандл админки, но если админка отделена (lazy-loaded only when path '/admin' accessed), это нормально.
Система уведомлений:
•	Было бы удобно, если админ получал уведомление о новом заказе или сообщении. Можно реализовать:
o	Email уведомления: использовать Firebase Functions or an SMTP service. Например, после создания заказа (в нашем Order API handler) – отправить письмо художнику "Новый заказ №...".
o	Push notifications / desktop: можно подключить Firebase Cloud Messaging, или просто rely on email/other channels.
o	Внутри админки: можно сделать периодический fetch новых данных или realtime:
	New orders: we could use MongoDB change streams or just refresh count. Probably overkill.
	New chat messages: Because admin can subscribe to collection(db, 'chats'), maybe we can just highlight if any doc has lastMessage.sender == user and admin hasn't read.
Эти аспекты выходят за рамки MVP, но можно добавить backlog.
Тестирование админских функций: особенно важно протестировать, так как они менее очевидны пользователям, но ошибки там критичны (могут поломать базу). Например, убедиться, что редактирование работы не сбрасывает поля неправильно, удаление требует подтверждения и не удаляет того, чего не надо, etc.
Потенциальная интеграция AR-функционала
Одной из отличительных задумок проекта является возможность просмотра художественных работ в дополненной реальности (AR). Это инновационная функция, которая не обязательна для первоначального запуска, но может значительно повысить интерактивность и ценность сайта для пользователей. В этом разделе рассмотрим, как AR может быть интегрирована в проект на будущее, какие технологии для этого подходят и что потребуется с технической стороны.
Цель AR-навигации: Дать пользователю возможность через камеру смартфона увидеть, как картина будет выглядеть у него на стене, или как скульптура впишется в интерьер, в реальном масштабе. Это особенно актуально для онлайн-продажи искусства, т.к. часто люди колеблются, не видя работу вживую. По данным кейсов, такая функция ощутимо увеличивает уверенность покупателей8thwall.com8thwall.com.
Выбор технологии AR: В веб-среде есть два основных подхода:
1.	Встроенные браузерные возможности (WebXR): Современные браузеры (Chrome Android, Safari iOS) поддерживают спецификацию WebXR для AR. Это позволяет прямо на веб-странице запускать сеанс AR, используя камеру. Для работы с WebXR обычно применяют библиотеки/фреймворки, как:
o	Three.js – с плагином WebXR. Позволяет размещать 3D объекты в пространстве, но требует много кода для плейн-детекции, управления.
o	<model-viewer> – готовый веб-компонент от Google, упрощающий 3D/AR показ. Он особенно хорошо работает для 3D-моделей: на Android вызывает ARCore, на iOS – AR QuickLook (показывает USDZ модель). Для плоских картин можно теоретически использовать модель плоскости.
o	A-Frame – высокоуровневый фреймворк для 3D сцены, есть компоненты для AR (например, mindar).
o	AR.js – библиотека для marker-based AR (распознавание маркеров или простых изображений) в браузере, не требующая тяжелых SDK, но она больше про фиксированные паттерны.
o	Babylon.js – движок, тоже умеет AR.
WebXR пока не на всех устройствах стабильно (iOS Safari поддерживает через QuickLook/SceneViewer, но вебXR API нет напрямую).
2.	Сторонние платформы WebAR: Пример – 8th Wall (ныне часть Niantic). 8thWall предлагает коммерческую платформу, которая через скрипты позволяет внедрить AR, работая почти на любом современном устройстве (включая iOS Safari, обходя ограничения).
o	Плюсы: высокоуровневые функции, отслеживание без маркеров (markerless) с хорошей стабильностью, есть готовые примеры, как для искусства (например, проект Saatchi Art использует 8th Wall8thwall.com).
o	Минусы: это платный сервис (подписка), и код не полностью под нашим контролем.
o	Альтернативы: Adobe Aero (не веб), WebAR by Verizon (меньше известна), но 8thWall – лидер.
В перспективе, если бюджет позволяет и нужен качественный продукт, можно интегрировать 8th Wall. Если хотим open-source путь – можно попытаться с WebXR + Three.js самостоятельно.
Как интегрировать (на уровне UX):
•	На странице детали работы мы уже предусмотрели кнопку "Посмотреть в AR". При нажатии:
o	Если AR не поддерживается на устройстве, можно либо скрывать кнопку, либо показать сообщение "AR не поддерживается на вашем устройстве".
o	Если поддерживается, запускаем AR-режим. Тут варианты:
1.	WebXR inline: Прямо на этой же странице разворачивается на весь экран "видоискатель" камеры с наложением объекта. Можно сделать <canvas> или <model-viewer>.
2.	Отдельная страница/вкладка: Например, 8thWall открывается по ссылке на отдельный веб-приложение, или <model-viewer> в AR на iOS откроет родное QuickLook (т.е. вообще покинет браузер но потом можно вернуться).
o	Для картин (2D), задача – отобразить плоское изображение, закрепленное на вертикальной поверхности (стене) и масштабированное к реальному размеру. У нас есть размеры (например 50x70 cm), их нужно использовать.
	В Three.js можно создать PlaneGeometry шириной 0.5m, высотой 0.7m, наложить текстуру (картинку). WebXR на мобильном умеет детектировать плоскости (ARCore/ARKit) – можно попросить пользователя навести на стену, когда появится подходящая плоскость, разместить там.
	У 8thWall есть фича image targets (например, навести на реальную картину?), но нам нужно наоборот. Они также имеют Instant Placement/surface detection.
	Saatchi Art в своем решении масштабирует картину согласно метаданным, и добавляет индикатор близости к стене8thwall.com, что повышает устойчивость размещения на маркерless стене.
o	Для скульптур (3D) – нужно иметь 3D модель. Если художник может предоставить модели, их можно хранить (например, GLB files). <model-viewer> идеально для этого:
o	<model-viewer src="model.glb" ar ar-scale="fixed" ar-placement="floor" camera-controls autoplay />
Это позволяет, например, разместить модель на полу/столе (AR Placement).
Требования к контенту для AR:
•	Для картин: хорошее ровное изображение (оно уже есть), плюс указание реальных размеров. В AR мы можем отобразить только картинку – без рамы. Если нужна рама – может быть PNG с прозрачным фоном. Можно даже генерировать легкий 3D: плоскость + малая глубина = картина с толщиной.
•	Для 3D объектов: обязательно наличие моделей. Если нет, AR тут не применить.
•	Для image tracking: можно, например, предоставить пользователю распечатать маркер (QR-код) и приклеить, и приложение бы размещало картину относительно маркера. Но markerless удобнее, хотя немного менее точно фиксируется в пространстве.
Интеграция 8th Wall (если): 8thWall предлагает добавить их script include, и настроить проект на их платформе. Код интеграции:
•	Зарегистрироваться, получить Client API Key.
•	В страницу добавить <script src="https://apps.8thwall.com/xrweb?appKey=YOUR_APP_KEY"></script>.
•	Затем использовать их XR8 API и A-Frame or Three.
•	8thWall имеет sample "Art Gallery"8thwall.com: он показывает информацию при наведении камеры на известное изображение (image target).
•	Но для наши цели ближе кейс Saatchi: Markerless placement. Вероятно, у них кастомное RPR (Rock Paper Reality) решение, но опирающееся на 8thWall's hit-tests.
Пример реализации AR на основе WebXR + Three.js (вкратце):
•	При нажатии "View in AR", запускаем полноэкранный <canvas> (maybe use a library for AR):
•	Use navigator.xr.requestSession("immersive-ar", { requiredFeatures: ['hit-test', 'dom-overlay'], domOverlay: { root: document.body } }).
•	Setup Three.js scene with camera from XR, attach ARButton (Three.js util).
•	On each frame, perform hit test to find surfaces, when user taps on screen, place painting mesh at that hit pose.
•	This is complex but doable. Perhaps outside scope of TЗ to detail fully, but we acknowledge complexity.
AR и мультиплатформенность:
•	Android (Chrome) – WebXR works with ARCore.
•	iOS (Safari) – no WebXR, so approach via <model-viewer> which uses AR QuickLook. QuickLook needs USDZ file for model (2D images can be converted to USDZ by wrapping in SceneKit plane).
•	Possibly have separate flows: if 3D model and model-viewer supported – use it; if only image – try an alternative approach (8thWall which supports Safari).
Размещение кнопки AR:
•	Можно также на странице работы сразу показать 3D модель (в плеере) для скульптур, с кнопкой [AR] – <model-viewer> делает именно так (кнопка AR в углу появляется, когда устройство поддерживает).
•	Для картин – <model-viewer> тоже можно применить: создать "плоскую модель" (plane geometry with texture) offline и export as glb/usdz. Это возможно: basically create 3D model of painting (width, height, minimal thickness). Then model-viewer can handle AR placement on vertical surfaces (?) Actually model-viewer currently supports vertical placement by user rotation, not automatic detection. But user can rotate/drag into place.
Back-end implications для AR:
•	Возможно, хранить ссылку на модель: e.g., artwork.modelUrl (GLB/USDZ).
•	If generating models on the fly (like for each painting, create USDZ), we might integrate a cloud function or external service (Reality Converter from Apple).
•	8thWall usage requires connecting to their cloud, possibly storing images targets or config.
Работы по AR – этап 3:
•	Нанять/назначить разработчика AR, выделить время на R&D.
•	Test on actual devices, ensure calibration of size (like if painting is 50x70, make sure it's that in AR relative to known reference e.g. one can calibrate by door height or use ARCore's units).
•	UI wise: give instructions: e.g., overlay text "Наведите камеру на стену" and a reticle until plane found.
•	Provide snapshot feature (some AR apps let you take a photo of AR view to share).
•	Evaluate performance: these libs can be heavy, ensure only loaded on demand.
Вдохновляющий пример (для отчета): Saatchi Art's "View In My Room" had success: 4x increase in conversion8thwall.com. Это может служить ориентиром, что усилия на AR оправданы.
Заключение
В этом техническом задании изложены все основные аспекты реализации сайта художника: от архитектуры MERN+Firebase, деталей интерфейса и базы данных до перспективной AR-функциональности. Предложенный стек и подходы призваны обеспечить масштабируемость (раздельные отвественности фронта/бэка, гибкость MongoDB), удобство разработки (использование Firebase для готовых решений, популярных React-библиотек для UI) и высокое качество UX/UI (продуманный темный дизайн, мультиязычность, интерактивность). Приведенная поэтапная реализация поможет последовательно достигнуть целей проекта.
При реализации важно следовать modern best practices, документировать API и компоненты, писать тесты для критичной логики (например, для оформления заказа) и постоянно сверяться с требованиями художника по визуальной части. В результате получится современный веб-сайт, отражающий уникальный стиль автора и предоставляющий посетителям удобный способ познакомиться и приобрести его работы, а в будущем – и испытать их виртуально у себя дома благодаря AR

